Structure Querry Language .
  Основные принципы реляционных баз данных: .
    * все данные на концептуальном уровне представляются в виде объектов, 
      заданных в виде строк и столбцов, называемых отношением, более распространенное
      название – таблица;
    * в пересечение строки и столбца таблицы можно занести только одно значение;
    * все операции выполняются над целыми отношениями и результатом этих операций
      является отношение.

  отношение .
    это структура данных целиком, набор записей (в обычном понимании – таблица)
  кортеж .
    это каждая строка , содержащая данные (более распространенный термин – запись )
    все кортежи в отношении должны быть различны;
  мощность .
    число кортежей в таблице (проще говоря, число записей)
    мощность отношения может быть любой (от 0 до бесконечности),
    порядок следования кортежей - неважен;
  атрибут .
    это столбец в таблице (более распространенный термин – поле )     
  размерность .
    это число атрибутов в таблице
    размерность отношения должна быть больше 0, порядок следования атрибутов существенен;
  домен атрибута .
    это допустимые значения (неповторяющиеся), которые можно занести в поле
      

    Порядок операторов в запросе: .
        SELECT 'столбцы или * для выбора всех столбцов; обязательно' .
        FROM 'таблица; обязательно' .
        WHERE 'условие/фильтрация, например, city = 'Moscow'; необязательно' .
        GROUP BY 'столбец, по которому хотим сгруппировать данные; необязательно' .
        HAVING 'условие/фильтрация на уровне сгруппированных данных; необязательно' .
        ORDER BY 'столбец, по которому хотим отсортировать вывод; необязательно' .
        LIMIT X -- ограничение количества выводимых записей .

  Типичные ошибки при написании SQL-запросов: .
  * Неправильный порядок или ошибки в ключевых словах. 
  * Неправильно названы используемые в запросе функции и операторы (например, DATEPART, а не DATE_PART).
  * Неправильно указаны имена столбцов.
  * Неправильно выполнена сортировка записей.
  * Неправильно проведены расчёты.
  * Пропущена запятая при перечислении столбцов в SELECT
  * Лишняя запятая после имени последнего столбца в SELECT
  * Не закрыты скобки (проверьте, что количество открывающих скобок равно количеству закрывающих).
  * Допущена ошибка в подзапросе (перед выполнением всего запроса проверьте, что работают отдельные подзапросы).
  * Запущены сразу несколько запросов, не разделённые точкой с запятой.

ORDER BY .
  Сортировать результат SQL-запроса можно сразу по нескольким колонкам,
  указывая их после ORDER BY через запятую вместе с направлением сортировки (`ASC` или `DESC`).
  При этом по умолчанию сортировка происходит по возрастанию, т.е.`ASC`указывать не обязательно.
  
  | SELECT column
  | FROM table
  | ORDER BY column -- сортировка по возрастанию
    
  | SELECT column
  | FROM table
  | ORDER BY column ASC -- сортировка по возрастанию
  |  
  | SELECT column
  | FROM table
  | ORDER BY column DESC -- сортировка по убыванию
  |
  | SELECT column_1, column_2
  | FROM table
  | ORDER BY column_1 DESC, column_2 -- сначала сортировка по первой колонке (по убыванию), 
  |                                  -- затем по второй (по возрастанию)

LIMIT .
  ограничивает число извлекаемых из таблицы записей.
  Записывается он так:
  | SELECT column
  | FROM table
  | LIMIT n 
  На месте n может быть любое целое число — ровно столько записей, сколько вам необходимо.
  Если n превысит количество записей в таблице, то в результат попадут все записи.   

AS .
  При составлении SQL-запросов колонкам в результирующей таблице можно присваивать любые другие имена
  (их называют «алиасы»). Это можно делать с помощью оператора `AS`:

  | SELECT name AS new_name
  | FROM table
  Если вдруг вам покажется, что на написание оператора AS уходит слишком много времени,
  то его можно опустить, указав новое имя колонки без него.
  Так тоже сработает:
  | SELECT name new_name
  | FROM table

CAST .
  Иногда возникает необходимость изменить тип данных в какой-нибудь колонке результирующей таблицы, 
  не меняя при этом свойства исходной таблицы.
  Например, можно преобразовать число в текст (тип данных VARCHAR) — для этого существует оператор`CAST`:
  | SELECT CAST(numbers AS VARCHAR)
  | FROM table
  Также это можно сделать с помощью специального синтаксиса:
  | SELECT numbers::VARCHAR
  | FROM table

DATE_PART .
  В отдельных таблицах некоторые колонки представлены в формате даты (DATE) и времени (TIMESTAMP).
  На практике бывают такие задачи, когда нужна, например, не вся дата, а какая-то её часть: год, месяц, день, час и т.д.
  Извлечь эту часть из исходных данных позволяет функция DATE_PART.
  Синтаксис следующий:
  | SELECT DATE_PART(part, column)
  На месте|part|нужно в кавычках указать ту часть, которую необходимо извлечь: 
  |'century', 'decade', 'year', 'month', 'day', 'hour', 'minute', 'second', 'microseconds', 'milliseconds',|
  |'dow', 'doy', 'epoch', 'isodow', 'isoyear', 'timezone', 'timezone_hour', 'timezone_minute'|
  На месте|column|следует указать нужную колонку либо конкретную дату/время.
  Пример:
  | SELECT DATE_PART('day', TIMESTAMP '2022-01-12')
  Результат:
  | 12

COALESCE .
  возвращает первое не NULL значение из списка поданных ей на вход аргументов:
  |   SELECT COALESCE(NULL, 'I am not NULL' , 25)
  | Результат:
  | 'I am not NULL'

  | SELECT COALESCE(NULL, 25, 'I am not NULL' )
  | Результат:
  | 25

  Чтобы заполнить пропуски в колонке, достаточно применить функцию COALESCE к колонке с пропусками
  и указать в качестве второго аргумента то значение, которое мы хотим видеть вместо NULL:
  | SELECT COALESCE(column, 'filler value')
  | FROM table
  Функция`COALESCE`принимает неограниченное количество аргументов. Он возвращает первый аргумент, который не равен NULL.
  Если все аргументы равны NULL,`COALESCE`функция вернет значение null.

  Функция`COALESCE`оценивает аргументы слева направо, пока не найдет первый ненулевой аргумент. 
  Все остальные аргументы из первого ненулевого аргумента не оцениваются.
  Функция COALESCE обеспечивает ту же функциональность, что`NVL`и `IFNULL` функция, предоставляемая стандартом SQL.
  MySQL имеет функцию`IFNULL`, а Oracle предоставляет`NVL`функцию.

  Мы часто используем эту`COLAESCE`функцию для замены нулевых значений значением по умолчанию при запросе данных.
  Например, мы хотим отобразить отрывок из сообщения в блоге, если отрывок не указан, мы можем использовать первые 
  150 символов содержимого сообщения. 
  Для этого мы можем использовать`COALESCE`функцию следующим образом:

  | SELECT
  | 	COALESCE (excerpt, LEFT(CONTENT, 150))
  | FROM
  | 	posts;

CONCAT .
  Функция`CONCAT`принимает на вход несколько аргументов и возвращает результат их последовательного сложения друг с другом.
  При этом аргументы не обязательно должны быть выражены строками — главное, они должны быть конвертируемыми в строки.
  | SELECT CONCAT('SQL', ' ', 'Simulator ', 2022)
  | Результат:
  | SQL Simulator 2022
CONCAT_WS .
  объединяет строки в одну, разделенную определенным разделителем. Кстати, WS означает с разделителем
  | CONCAT_WS(separator,str_1,str_2,...);

Арифметические операторы .
  Для работы с числовыми значениями в PostgreSQL доступны разные арифметические операторы:
  `+ - * / % ^` etc. [https://www.postgresql.org/docs/9.3/functions-math.html]
  Если бы мы захотели перевести 6200 рублей в доллары по курсу 1 доллар = 62 рубля,
  то операция выглядела бы следующим образом:
  | SELECT 6200 / 62
  | Результат:
  | 100

CASE .
  Выражение CASE проходит через условия и возвращает значение при выполнении первого условия 
  (как оператор if-then-else). Итак, как только условие истинно, оно прекращает чтение и возвращает результат.
  Если никакие условия не выполняются, возвращается значение в ELSE предложении.
  Если ELSE часть отсутствует и ни одно условие не выполняется, возвращается NULL.
| CASE
|     WHEN condition1 THEN result1
|     WHEN condition2 THEN result2
|     WHEN conditionN THEN resultN
|     ELSE result
| END;
  Пример: .
  Следующая конструкция разобъёт весь список наименований на три категории: «мясо», «рыба» и «другое». 
  Соответственно, если в первых двух условиях мы не учтём какие-то наименования из колонки name 
  (например, «телятину»), то они попадут в категорию «другое».
  | SELECT CASE 
  |        WHEN name='свинина' OR name='баранина' OR name='курица' THEN 'мясо'
  |        WHEN name='треска' OR name='форель' OR name='окунь' THEN 'рыба'
  |        ELSE 'другое'
  |        END AS сategory
  | FROM table
  Пример2: .
 Повысьте цену на 5% только на те товары, цена которых превышает 100 рублей. Цену остальных товаров оставьте без изменений.
 Также не повышайте цену на икру, которая и так стоит 800 рублей. Выведите id и наименования всех товаров, их старую и новую цену.
 Цену округлять не нужно. Колонку с новой ценой снова назовите new_price. 
 Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.
  |   SELECT product_id, name, price,
  |     CASE 
  |     WHEN name = 'икра' THEN price
  |     WHEN price > 100 THEN price * 1.05 
  |     ELSE price
  |     END AS new_price
  | FROM products
  | ORDER BY new_price DESC, product_id
  приоритеты выполнения операций: .
    * умножение и деление (* и /)
    * сложение и вычитание (+ и -)
    * операторы сравнения (=, !=, >, <, >=, <=)
    * NOT
    * AND
    * OR

LIKE .
| value LIKE pattern
  Проверяет строки на соответствие заданному шаблону: если строка ему соответствует, то возвращается TRUE,
  в противном случае — FALSE. 

  Шаблоны могут содержать как обычные символы, так и символы-шаблоны: знак процента ( % ) и подчёркивание ( _ ).
  Подчёркивание подменяет любой одиночный символ, а знак процента — любую (в том числе и пустую) последовательность символов:

  Обратите внимание на последний пример: оператор LIKE чувствителен к регистру.
  Если шаблон не содержит знаков процента и подчёркиваний, тогда шаблон представляет
  собой строку и LIKE работает как оператор сравнения, проверяя строки на точное совпадение.

IN/BETWEEN .
  | WHERE product_name IN (product_1, product_2, product_3, ...)
  | WHERE value BETWEEN 5 AND 10
  | WHERE date BETWEEN '2022-11-10' AND '2022-12-10'
  | WHERE product_name NOT IN (product_1, product_2, product_3, ...)
  | WHERE value NOT BETWEEN 5 AND 10

DISTINCT .
  позволяет отбирать уникальные значения в колонке, т.е.избавляться от всех дубликатов. 
  Указывается`DISTINCT`сразу после`SELECT`:
  | SELECT DISTINCT column
  | FROM table
  Если вы укажете несколько столбцов,`DISTINCT`предложение будет оценивать дубликат на основе комбинации значений этих столбцов.
  | SELECT
  |    DISTINCT column1, column2
  | FROM
  |    table_name;
  В этом случае комбинация значений в обоих столбцах column1 и column2 будет использоваться для оценки дубликата.
  PostgreSQL также позволяет DISTINCT ON (expression) сохранить «первую» строку каждой группы дубликатов,
  используя следующий синтаксис:
  |   SELECT
  |    DISTINCT ON (column1) column_alias,
  |    column2
  | FROM
  |    table_name
  | ORDER BY
  |    column1,
  |    column2;
  Порядок строк, возвращаемых`SELECT`оператором, не указан, поэтому «первая» строка каждой группы дубликата также не указана.
  Хорошей практикой является всегда использовать`ORDER BY`предложение с,`DISTINCT ON(expression)`чтобы сделать результирующий
  набор предсказуемым.
  Обратите внимание, что`DISTINCT ON`выражение должно соответствовать самому левому выражению в`ORDER BY`предложении.

АГРЕГИРУЮЩИЕ ФУНКЦИИ .
  Агрегирующие функции выполняют вычисления для набора строк и возвращают одну строку.
  * COUNT() — считает количество значений в колонке.
  * SUM() — вычисляет сумму значений.
  * AVG() — вычисляет среднее значение.
  * MAX() — вычисляет максимальное значение.
  * MIN() — вычисляет минимальное значение.
  Некоторые из вышеуказанных функций нельзя применять к колонкам с текстом, датами и временем, так как не вполне понятно,
  что, например, означает найти среднее значение или сумму наименований товаров. 
  В то же время «максимальное» наименование товара вычислить можно — функция MAX() будет искать наибольшее значение 
  в упорядоченной последовательности символов (в данном случае — упорядоченной по алфавиту).

  Мы часто используем агрегатные функции с`GROUP BY`предложением в`SELECT`операторе. В этих случаях`GROUP BY`предложение
  делит набор результатов на группы строк, и агрегатные функции выполняют расчет для каждой группы,
  например, максимум, минимум, среднее и т. д.
  Вы можете использовать агрегатные функции как выражения только в следующих предложениях:
  * SELECT
  * HAVING

Другие функции работы со строками: .
ASCII .
Возвращает ASCII код символа или Unicode код для UTF8 символа	
| ASCII(‘A’)	-- 65
CHR .
  конвертирует ASCII в символ или Unicode код в случае UTF8 
  | CHR(65)	-- ‘A’
CONCAT .
	Concatenate two or more strings into one	CONCAT(‘A’,’B’,’C’)	‘ABC’
CONCAT_WS .
	Concatenate strings with a separator	CONCAT_WS(‘,’,’A’,’B’,’C’)	‘A,B,C’
FORMAT .
	Format arguments based on a format string	FORMAT(‘Hello %s’,’PostgreSQL’)	‘Hello PostgreSQL’
INITCAP .
	преобразует строковое выражение в правильный регистр или регистр заглавий, 
  в котором первая буква каждого слова является прописной, а остальные символы — строчными.	
  | INITCAP(‘hI tHERE’)
  | Hi There
LEFT .
	Return the first n character in a string	LEFT(‘ABC’,1)	‘A’
LENGTH .
	Return the number of characters in a string	LENGTH(‘ABC’)	3
LOWER .
	Convert a string to lowercase	LOWER(‘hI tHERE’)	‘hi there’
LPAD .
	Pad on the left a a string with a character to a certain length	LPAD(‘123′, 5, ’00’)	‘00123’
LTRIM .
	Remove the longest string that contains specified characters from the left of the input string	LTRIM(‘00123’)	‘123’
MD5 .
	Return MD5 hash of a string in hexadecimal	MD5(‘ABC’)	
POSITION .
	Return the location of a substring in a string	POSTION(‘B’ in ‘A B C’)	3
REGEXP_MATCHES .
	Match a POSIX regular expression against a string and returns the matching substrings	SELECT REGEXP_MATCHES(‘ABC’, ‘^(A)(..)$’, ‘g’);	{A,BC}
REGEXP_REPLACE .
	Replace substrings that match a POSIX regular expression by a new substring	REGEXP_REPLACE(‘John Doe’,'(.*) (.*)’,’\2, \1′);	‘Doe, John’
REPEAT .
	Repeat string the specified number of times	REPEAT(‘*’, 5)	‘*****’
REPLACE .
	Replace all occurrences in a string of substring from with substring to	REPLACE(‘ABC’,’B’,’A’)	‘AAC’
REVERSE .
	Return reversed string.	REVERSE(‘ABC’)	‘CBA’
RIGHT .
	Return last n characters in the string. When n is negative, return all but first |n| characters.	RIGHT(‘ABC’, 2)	‘BC’
RPAD .
	Pad on the right of a string with a character to a certain length	RPAD(‘ABC’, 6, ‘xo’)	‘ABCxox’
RTRIM .
	Remove the longest string that contains specified characters from the right of the input string	RTRIM(‘abcxxzx’, ‘xyz’)	‘abc’
SPLIT_PART .
	разбивает строку по указанному разделителю и возвращает n-ю подстроку.	
  | SPLIT_PART(string, delimiter, position)
  | SPLIT_PART('2017-12-31','-'',2)	
  | '12'
SUBSTRING .
	Извлекает подстроку из строки
  | SUBSTRING ( string ,start_position , length )
  | SUBSTRING('ABC',1,1)
  | 'A'
TRIM .
	Убрирает указанные символы из начала и/или конца строки:	
  | TRIM([LEADING | TRAILING | BOTH] [characters] FROM string)
  | TRIM(' ABC  ')
  | 'ABC'
UPPER .
	конвертирует строку в верхний регистр
  | UPPER('hI tHERE')
  | 'HI THERE'

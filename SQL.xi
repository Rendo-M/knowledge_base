Structure Querry Language .
  Основные принципы реляционных баз данных: .
    * все данные на концептуальном уровне представляются в виде объектов, 
      заданных в виде строк и столбцов, называемых отношением, более распространенное
      название – таблица;
    * в пересечение строки и столбца таблицы можно занести только одно значение;
    * все операции выполняются над целыми отношениями и результатом этих операций
      является отношение.

  отношение .
    это структура данных целиком, набор записей (в обычном понимании – таблица)
  кортеж .
    это каждая строка , содержащая данные (более распространенный термин – запись )
    все кортежи в отношении должны быть различны;
  мощность .
    число кортежей в таблице (проще говоря, число записей)
    мощность отношения может быть любой (от 0 до бесконечности),
    порядок следования кортежей - неважен;
  атрибут .
    это столбец в таблице (более распространенный термин – поле )     
  размерность .
    это число атрибутов в таблице
    размерность отношения должна быть больше 0, порядок следования атрибутов существенен;
  домен атрибута .
    это допустимые значения (неповторяющиеся), которые можно занести в поле
      

    Порядок операторов в запросе: .
        SELECT 'столбцы или * для выбора всех столбцов; обязательно' .
        FROM 'таблица; обязательно' .
        WHERE 'условие/фильтрация, например, city = 'Moscow'; необязательно' .
        GROUP BY 'столбец, по которому хотим сгруппировать данные; необязательно' .
        HAVING 'условие/фильтрация на уровне сгруппированных данных; необязательно' .
        ORDER BY 'столбец, по которому хотим отсортировать вывод; необязательно' .
        LIMIT X -- ограничение количества выводимых записей .

    Тем не менее важно понимать, что порядок выполнения операторов в
    СУБД несколько отличается от порядка их написания в запросе.
    В упрощённом виде порядок выполнения запроса в PostgreSQL такой: .
      FROM -- указание источника данных .
      WHERE -- фильтрация данных .
      GROUP BY -- группировка данных .
      HAVING -- фильтрация данных после группировки .
      SELECT -- перечисление полей результирующей таблицы .
      ORDER BY -- сортировка результирующей таблицы .
      LIMIT -- ограничение количества выводимых записей .

    Таким образом:
    * Сначала с помощью FROM определяется таблица.
    * Затем в соответствии с указанным в WHERE условием из этой таблицы отбираются записи.
    * Потом выбранные данные группируются и агрегируются с помощью GROUP BY.
    * Далее из агрегированных записей отбираются те, которые удовлетворяют условию в HAVING.
    * Только после этого в соответствии с указанными в SELECT инструкциями формируется результирующая таблица — 
      производятся все необходимые вычисления, присваиваются новые имена и т.д.
    * Затем результирующая таблица сортируется в соответствии с ORDER BY.
    * И наконец срабатывает ограничение на количество строк, указанное в LIMIT.

    И ещё один важный совет. Обратите внимание, что фильтрацию данных по неагрегированным значениям
    можно делать как в блоке WHERE, так и в блоке HAVING. Внимательно посмотрите на следующие запросы:

   | SELECT sex, COUNT(user_id)
   | FROM users
   | WHERE sex != 'male'
   | GROUP BY sex

   | SELECT sex, COUNT(user_id)
   | FROM users
   | GROUP BY sex
   | HAVING sex != 'male'
    Их результат будет одинаковым.
    Однако делать фильтрацию по неагрегированным данным рекомендуется именно в блоке WHERE, 
    т.е. заранее. В таком случае вы ещё до группировки убираете из расчётов ненужные вам данные
    и таким образом не расходуете вычислительные ресурсы на подсчёт значений, которые всё равно
    будут отфильтрованы вами позже.
    Это важный момент, касающийся оптимизации SQL-запросов.

  Подзапросы .
    — это всего лишь запрос внутри другого запроса.
    Подзапросы могут применяться в следующих частях основного запроса: .
    * в операторе FROM;
    * в операторе SELECT (если запрос возвращает один столбец с одним значением);
    * в операторах WHERE и HAVING (если запрос возвращает один столбец с одним или несколькими значениями).
    
    Прежде всего важно понять, что к результату выполнения подзапроса можно обращаться так же, 
    как и к таблицам в базе данных, т.е. использовать их в блоке FROM вместо имеющихся таблиц:
    | SELECT column_1
    | FROM (
    |     SELECT column_1, column_2
    |     FROM table
    | ) AS subquery_1
    В рамках данного запроса сначала будет выполнен подзапрос, который отберёт колонки 
    column_1 и column_2 из таблицы table, а затем уже из образовавшейся таблицы основной запрос выберет колонку column_1.

    Подзапрос, возвращающий одно значение, может использоваться как обычное значение совместно с операторами сравнения.
    
    Важный момент: при использовании подзапроса в блоке FROM сформированной на основе подзапроса таблице
    необходимо присвоить какой-нибудь алиас, иначе основной запрос не сработает.
    В примере выше мы обозначили результат подзапроса как subquery_1.
    Кроме того, уровней вложенности может быть несколько: .
    | SELECT column_1
    | FROM (
    |     SELECT column_1, column_2
    |     FROM (
    |         SELECT column_1, column_2, column_3
    |         FROM table
    |     ) AS subquery_1
    | ) AS subquery_2
    В данном случае последовательность работы запроса такая: 
    сначала будет выполнен подзапрос, возвращающий результат subquery_1, 
    затем подзапрос, возвращающий результат subquery_2, 
    и только потом в результате основного подзапроса попадёт колонка column_1. 
    В результате получается что-то похожее на матрёшку, при этом к основной таблице table обращается
    только самый первый подзапрос subquery_1.
    Приведённый пример довольно условный и на практике колонки таким образом отбирать не стоит,
    но общую идею он должен передавать.
    Понимание того, как работают подзапросы в блоке FROM, пригодится, при оъединении разных таблиц.
    Подзапрос, возвращающий несколько значений, может использоваться в блоке`WHERE`совместно с оператором`IN` — 
    например, когда нам нужно проверить, совпадает ли значение в столбце с одним из значений из определённого множества, 
    полученного в результате выполнения подзапроса.
    При использовании в операторе`WHERE`табличного выражения обратиться просто к его имени нельзя —
    необходимо предварительно выбрать все его записи. т.е. написать подзапрос. 
    При этом в табличном выражении должен быть всего один столбец, иначе база данных вернёт ошибку.

  Типичные ошибки при написании SQL-запросов: .
  * Неправильный порядок или ошибки в ключевых словах. 
  * Неправильно названы используемые в запросе функции и операторы (например, DATEPART, а не DATE_PART).
  * Неправильно указаны имена столбцов.
  * Неправильно выполнена сортировка записей.
  * Неправильно проведены расчёты.
  * Пропущена запятая при перечислении столбцов в SELECT
  * Лишняя запятая после имени последнего столбца в SELECT
  * Не закрыты скобки (проверьте, что количество открывающих скобок равно количеству закрывающих).
  * Допущена ошибка в подзапросе (перед выполнением всего запроса проверьте, что работают отдельные подзапросы).
  * Запущены сразу несколько запросов, не разделённые точкой с запятой.

ORDER BY .
  Сортировать результат SQL-запроса можно сразу по нескольким колонкам,
  указывая их после ORDER BY через запятую вместе с направлением сортировки (`ASC` или `DESC`).
  При этом по умолчанию сортировка происходит по возрастанию, т.е.`ASC`указывать не обязательно.
  
  | SELECT column
  | FROM table
  | ORDER BY column -- сортировка по возрастанию
    
  | SELECT column
  | FROM table
  | ORDER BY column ASC -- сортировка по возрастанию
  |  
  | SELECT column
  | FROM table
  | ORDER BY column DESC -- сортировка по убыванию
  |
  | SELECT column_1, column_2
  | FROM table
  | ORDER BY column_1 DESC, column_2 -- сначала сортировка по первой колонке (по убыванию), 
  |                                  -- затем по второй (по возрастанию)

LIMIT .
  ограничивает число извлекаемых из таблицы записей.
  Записывается он так:
  | SELECT column
  | FROM table
  | LIMIT n 
  На месте n может быть любое целое число — ровно столько записей, сколько вам необходимо.
  Если n превысит количество записей в таблице, то в результат попадут все записи.   

WITH .
  позволяет создавать так называемые табличные выражения 
  (CTE, common table expressions) — временные таблицы, существующие только для одного запроса.
  Их основное предназначение заключается в разбиении сложных запросов на несколько частей.
  Табличные выражения создаются так: .
  | WITH subquery_1 AS (
  |     SELECT column_1, column_2
  |     FROM table
  |     )
  | SELECT column_1
  | FROM subquery_1 
  Сравните запрос выше с результатом запроса из прошлого шага:
  | SELECT column_1
  | FROM (
  |     SELECT column_1, column_2
  |     FROM table
  | ) AS subquery_1
  Оператор WITH может содержать несколько табличных выражений, причём к указанным ранее выражениям 
  можно обращаться в последующих выражениях:
  | WITH subquery_1 AS (
  |     SELECT column_1, column_2, column_3
  |     FROM table
  |     ),
  |      subquery_2 AS (
  |     SELECT column_1, column_2
  |     FROM subquery_1
  |     )
  | SELECT column_1
  | FROM subquery_2
  Можете снова сравнить запрос выше с запросом из прошлого шага:
  | SELECT column_1
  | FROM (
  |     SELECT column_1, column_2
  |     FROM (
  |         SELECT column_1, column_2, column_3
  |         FROM table
  |     ) AS subquery_1
  | ) AS subquery_2
  

  Использовать в своих запросах оператор WITH или нет — решать вам,
  но в некоторых случаях он может упростить работу с кодом запроса.
  Подробнее про WITH и табличные выражения можно почитать [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-cte/]

AS .
  При составлении SQL-запросов колонкам в результирующей таблице можно присваивать любые другие имена
  (их называют «алиасы»). Это можно делать с помощью оператора `AS`:

  | SELECT name AS new_name
  | FROM table
  Если вдруг вам покажется, что на написание оператора AS уходит слишком много времени,
  то его можно опустить, указав новое имя колонки без него.
  Так тоже сработает:
  | SELECT name new_name
  | FROM table

CAST .
  Иногда возникает необходимость изменить тип данных в какой-нибудь колонке результирующей таблицы, 
  не меняя при этом свойства исходной таблицы.
  Например, можно преобразовать число в текст (тип данных VARCHAR) — для этого существует оператор`CAST`:
  | SELECT CAST(numbers AS VARCHAR)
  | FROM table
  Также это можно сделать с помощью специального синтаксиса:
  | SELECT numbers::VARCHAR
  | FROM table


Функции даты .
[https://www.postgresqltutorial.com/postgresql-date-functions/]

DATE_PART .
  В отдельных таблицах некоторые колонки представлены в формате даты (DATE) и времени (TIMESTAMP).
  На практике бывают такие задачи, когда нужна, например, не вся дата, а какая-то её часть: год, месяц, день, час и т.д.
  Извлечь эту часть из исходных данных позволяет функция DATE_PART.
  Синтаксис следующий:
  | SELECT DATE_PART(part, column)
  На месте|part|нужно в кавычках указать ту часть, которую необходимо извлечь: 
  |'century', 'decade', 'year', 'month', 'day', 'hour', 'minute', 'second', 'microseconds', 'milliseconds',|
  |'dow', 'doy', 'epoch', 'isodow', 'isoyear', 'timezone', 'timezone_hour', 'timezone_minute'|
  На месте|column|следует указать нужную колонку либо конкретную дату/время.
  Пример:
  | SELECT DATE_PART('day', TIMESTAMP '2022-01-12')
  Результат:
  | 12

DATE_TRUNC .
  используется для усечения дат и времени, т.е. она работает почти как округление`ROUND`, 
  только для типов данных`TIMESTAMP`и`INTERVAL`
 Синтаксис, как и у `DATE_PART`:
  | SELECT DATE_TRUNC(part, column) 
  На месте`part`в кавычках указывается, до какой точности следует обрезать переданное значение времени:
  'year', 'month', 'day', 'hour' и т.д.
  Возвращаемое значение имеет тип`TIMESTAMP`или`INTERVAL`, а все «части» исходного значения, менее значимые, 
  чем заданная «часть», приравниваются к нулю (или единице, если это номер дня или месяца):
  | SELECT DATE_TRUNC('month', TIMESTAMP '2022-01-12 08:55:30')
  | Результат:
  | 01/01/22 00:00
  | SELECT DATE_TRUNC('day', TIMESTAMP '2022-01-12 08:55:30')
  | Результат:
  | 12/01/22 00:00	
  | SELECT DATE_TRUNC('hour', TIMESTAMP '2022-01-12 08:55:30')
  | Результат:
  | 12/01/22 08:00	

EXTRACT .
  | EXTRACT(field FROM source)
  field .
  указывает, какое поле следует извлечь из значения даты/времени:
  * CENTURY	      Век
  * DAY	          День месяца (1-31)
  * DECADE	      Десятилетие, то есть год, разделенный на 10
  * DOW	          День недели с воскресенья (0) по субботу (6)
  * DOY	          День года в диапазоне от 1 до 366.
  * EPOCH	        Количество секунд с 1970-01-01 00:00:00 UTC
  * HOUR	        Час (0-23)
  * ISODOW	      День недели в соответствии с ISO 8601 с понедельника (1) по воскресенье (7)
  * ISOYEAR	      ISO 8601 номер недели года
  * MICROSECONDS	Поле секунд, включая дробные части, умноженные на 1000000
  * MILLENNIUM	  Тысячелетие
  * MILLISECONDS	Поле секунд, включая дробные части, умноженные на 1000
  * MINUTE	      Минуты (0-59)
  * MONTH	        Месяц, 1-12
  * QUARTER	      квартал года
  * SECOND	      Количество секунд
  * TIMEZONE	    Смещение часового пояса от UTC, измеряемое в секундах
  * TIMEZONE_HOUR	Часовой компонент смещения часового пояса
  * TIMEZONE_MINUTE	Минутная составляющая смещения часового пояса
  * WEEK	        Номер недели ISO 8601 в году
  * YEAR	        	Год
  source .
  Является значением типа`TIMESTAMP`или`INTERVALЕ`Если вы передаете`DATE`значение, функция преобразует его в`TIMESTAMP`значение.

TO_DATE() .
  Преобразует строковый литерал в значение даты . Ниже показан синтаксис`TO_DATE()`функции:
  | TO_DATE(text,format)
  Первый аргумент — это строка, которую вы хотите преобразовать в дату. Второй - формат ввода. 
  подробнее о шаблонах форматирования тут: [https://www.postgresqltutorial.com/postgresql-date-functions/postgresql-to_date/]
  Если вы передадите недопустимую строку даты, 
  TO_DATE() функция попытается преобразовать ее в допустимую дату и выдаст ошибку, если не сможет. 
  Примеры: .
    | TO_DATE('2017 Feb 20','YYYY Mon DD');
    | 2017-02-10
    | SELECT TO_DATE('20170103','YYYYMMDD');
    | 2017-01-03

TO_TIMESTAMP() .
  преобразует строку в отметку времени в соответствии с указанным форматом.
  | TO_TIMESTAMP(timestamp, format)
  Особенности .
    * Функция пропускает пробелы во входной строке, если не используется глобальная опция фиксированного формата (`FX`префикс).
    * Функция проверяет входную строку с минимальной проверкой ошибок. 
      Он попытается максимально преобразовать входную строку в допустимую временную метку
    * При преобразовании строки в отметку времени`TO_TIMESTAMP()`функция обрабатывает миллисекунды 
      или микросекунды как секунды после запятой:
      | SELECT 
      |     TO_TIMESTAMP('01-01-2017 10:2', 'DD-MM-YYYY SS:MS');
         |  2017-01-01 00:00:10.2-07  
      В этом примере 2 — это не 2 миллисекунды, а 200.
      Чтобы получить 2 миллисекунды, вы должны использовать 01-01-2017 10:002. 
      В этом случае 002интерпретируется как 0.002 секунды, что эквивалентно 2 миллисекундам.
    * Если год меньше четырех цифр,`TO_TIMESTAMP()`он будет скорректирован до ближайшего года, 
      например, 99 становится 1999, 17 становится 2017.     
  Пример: .
    | SELECT TO_TIMESTAMP(
    |     '2017-03-31 9:30:20',
    |     'YYYY-MM-DD HH:MI:SS'
    |   );

    |  2017-03-31 09:30:20-07
    подробне: [https://www.postgresqltutorial.com/postgresql-date-functions/postgresql-to_timestamp/]

NOW() .
  озвращает текущую дату и время. Возвращаемый тип`NOW()`функции — timestamp with time zone

LOCALTIMESTAMP .
CURRENT_TIMESTAMP .
  Функция`LOCALTIMESTAMP`возвращает`TIMESTAMP`значение, представляющее дату и время начала текущей транзакции.
    | LOCALTIMESTAMP(precision)
  Аргумент`precision`указывает точность второго поля в долях секунд.
  Аргумент точности является необязательным. Если вы опустите его, его значение по умолчанию равно 6.
  Функция`LOCALTIMESTAMP`возвращает`TIMESTAMP`значение без часового пояса, 
  а`CURRENT_TIMESTAMP`функция возвращает значение`TIMESTAMP`с часовым поясом.

LOCALTIME .
CURRENT_TIME .
  Функция`LOCALTIME`возвращает`TIME`значение, представляющее время начала текущей транзакции
  `CURRENT_TIME`возвращает`TIME WITH TIME ZONE`значение, представляющее текущее время с часовым поясом
  | LOCALTIME(precision)
  | CURRENT_TIME(precision)
  Аргумент precisionуказывает точность второго поля в долях секунд.
  Если вы опустите аргумент, по умолчанию он равен 6.

CURRENT_DATE .
  `CURRENT_DATE`возвращает`DATE`значение, представляющее текущую дату.
  | CURRENT_DATE

INTERVAL .
  Чтобы отложить от даты или прибавить к ней какой-то промежуток времени, 
  можно использовать несложные арифметические операции с датами. 
  Например, от текущей даты можно отнять какой-то промежуток`INTERVAL`:
  | SELECT NOW() - INTERVAL '1 year 2 months 1 week'
  | Результат:
  | 10/10/21 19:32
  NOW() — функция, которая позволяет получать текущую дату и время (в вашем случае она будет другой): .
  | SELECT NOW()
  | Результат:
  | 17/12/22 19:32

COALESCE .
  возвращает первое не NULL значение из списка поданных ей на вход аргументов:
  |   SELECT COALESCE(NULL, 'I am not NULL' , 25)
  | Результат:
  | 'I am not NULL'

  | SELECT COALESCE(NULL, 25, 'I am not NULL' )
  | Результат:
  | 25

  Чтобы заполнить пропуски в колонке, достаточно применить функцию COALESCE к колонке с пропусками
  и указать в качестве второго аргумента то значение, которое мы хотим видеть вместо NULL:
  | SELECT COALESCE(column, 'filler value')
  | FROM table
  Функция`COALESCE`принимает неограниченное количество аргументов. Он возвращает первый аргумент, который не равен NULL.
  Если все аргументы равны NULL,`COALESCE`функция вернет значение null.

  Функция`COALESCE`оценивает аргументы слева направо, пока не найдет первый ненулевой аргумент. 
  Все остальные аргументы из первого ненулевого аргумента не оцениваются.
  Функция COALESCE обеспечивает ту же функциональность, что`NVL`и `IFNULL` функция, предоставляемая стандартом SQL.
  MySQL имеет функцию`IFNULL`, а Oracle предоставляет`NVL`функцию.

  Мы часто используем эту`COLAESCE`функцию для замены нулевых значений значением по умолчанию при запросе данных.
  Например, мы хотим отобразить отрывок из сообщения в блоге, если отрывок не указан, мы можем использовать первые 
  150 символов содержимого сообщения. 
  Для этого мы можем использовать`COALESCE`функцию следующим образом:

  | SELECT
  | 	COALESCE (excerpt, LEFT(CONTENT, 150))
  | FROM
  | 	posts;

CONCAT .
  Функция`CONCAT`принимает на вход несколько аргументов и возвращает результат их последовательного сложения друг с другом.
  При этом аргументы не обязательно должны быть выражены строками — главное, они должны быть конвертируемыми в строки.
  | SELECT CONCAT('SQL', ' ', 'Simulator ', 2022)
  | Результат:
  | SQL Simulator 2022

CONCAT_WS .
  объединяет строки в одну, разделенную определенным разделителем. Кстати, WS означает с разделителем
  | CONCAT_WS(separator,str_1,str_2,...);

Арифметические операторы .
  Для работы с числовыми значениями в PostgreSQL доступны разные арифметические операторы:
  `+ - * / % ^` etc. [https://www.postgresql.org/docs/9.3/functions-math.html]
  Если бы мы захотели перевести 6200 рублей в доллары по курсу 1 доллар = 62 рубля,
  то операция выглядела бы следующим образом:
  | SELECT 6200 / 62
  | Результат:
  | 100

CASE .
  Выражение CASE проходит через условия и возвращает значение при выполнении первого условия 
  (как оператор if-then-else). Итак, как только условие истинно, оно прекращает чтение и возвращает результат.
  Если никакие условия не выполняются, возвращается значение в ELSE предложении.
  Если ELSE часть отсутствует и ни одно условие не выполняется, возвращается NULL.
| CASE
|     WHEN condition1 THEN result1
|     WHEN condition2 THEN result2
|     WHEN conditionN THEN resultN
|     ELSE result
| END;
  Пример: .
  Следующая конструкция разобъёт весь список наименований на три категории: «мясо», «рыба» и «другое». 
  Соответственно, если в первых двух условиях мы не учтём какие-то наименования из колонки name 
  (например, «телятину»), то они попадут в категорию «другое».
  | SELECT CASE 
  |        WHEN name='свинина' OR name='баранина' OR name='курица' THEN 'мясо'
  |        WHEN name='треска' OR name='форель' OR name='окунь' THEN 'рыба'
  |        ELSE 'другое'
  |        END AS сategory
  | FROM table
  Пример2: .
 Повысьте цену на 5% только на те товары, цена которых превышает 100 рублей. Цену остальных товаров оставьте без изменений.
 Также не повышайте цену на икру, которая и так стоит 800 рублей. Выведите id и наименования всех товаров, их старую и новую цену.
 Цену округлять не нужно. Колонку с новой ценой снова назовите new_price. 
 Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.
  |   SELECT product_id, name, price,
  |     CASE 
  |     WHEN name = 'икра' THEN price
  |     WHEN price > 100 THEN price * 1.05 
  |     ELSE price
  |     END AS new_price
  | FROM products
  | ORDER BY new_price DESC, product_id
  приоритеты выполнения операций: .
    * умножение и деление (* и /)
    * сложение и вычитание (+ и -)
    * операторы сравнения (=, !=, >, <, >=, <=)
    * NOT
    * AND
    * OR

LIKE .
| value LIKE pattern
  Проверяет строки на соответствие заданному шаблону: если строка ему соответствует, то возвращается TRUE,
  в противном случае — FALSE. 

  Шаблоны могут содержать как обычные символы, так и символы-шаблоны: знак процента ( % ) и подчёркивание ( _ ).
  Подчёркивание подменяет любой одиночный символ, а знак процента — любую (в том числе и пустую) последовательность символов:

  Обратите внимание на последний пример: оператор LIKE чувствителен к регистру.
  Если шаблон не содержит знаков процента и подчёркиваний, тогда шаблон представляет
  собой строку и LIKE работает как оператор сравнения, проверяя строки на точное совпадение.

IN/BETWEEN .
  | WHERE product_name IN (product_1, product_2, product_3, ...)
  | WHERE value BETWEEN 5 AND 10
  | WHERE date BETWEEN '2022-11-10' AND '2022-12-10'
  | WHERE product_name NOT IN (product_1, product_2, product_3, ...)
  | WHERE value NOT BETWEEN 5 AND 10

DISTINCT .
  позволяет отбирать уникальные значения в колонке, т.е.избавляться от всех дубликатов. 
  Указывается`DISTINCT`сразу после`SELECT`:
  | SELECT DISTINCT column
  | FROM table
  Если вы укажете несколько столбцов,`DISTINCT`предложение будет оценивать дубликат на основе комбинации значений этих столбцов.
  | SELECT
  |    DISTINCT column1, column2
  | FROM
  |    table_name;
  В этом случае комбинация значений в обоих столбцах column1 и column2 будет использоваться для оценки дубликата.
  PostgreSQL также позволяет DISTINCT ON (expression) сохранить «первую» строку каждой группы дубликатов,
  используя следующий синтаксис:
  |   SELECT
  |    DISTINCT ON (column1) column_alias,
  |    column2
  | FROM
  |    table_name
  | ORDER BY
  |    column1,
  |    column2;
  Порядок строк, возвращаемых`SELECT`оператором, не указан, поэтому «первая» строка каждой группы дубликата также не указана.
  Хорошей практикой является всегда использовать`ORDER BY`предложение с,`DISTINCT ON(expression)`чтобы сделать результирующий
  набор предсказуемым.
  Обратите внимание, что`DISTINCT ON`выражение должно соответствовать самому левому выражению в`ORDER BY`предложении.

АГРЕГИРУЮЩИЕ ФУНКЦИИ .
  Агрегирующие функции выполняют вычисления для набора строк и возвращают одну строку.
  * COUNT() — считает количество значений в колонке.
  * SUM() — вычисляет сумму значений.
  * AVG() — вычисляет среднее значение.
  * MAX() — вычисляет максимальное значение.
  * MIN() — вычисляет минимальное значение.
  Некоторые из вышеуказанных функций нельзя применять к колонкам с текстом, датами и временем, так как не вполне понятно,
  что, например, означает найти среднее значение или сумму наименований товаров. 
  В то же время «максимальное» наименование товара вычислить можно — функция MAX() будет искать наибольшее значение 
  в упорядоченной последовательности символов (в данном случае — упорядоченной по алфавиту).

  Мы часто используем агрегатные функции с`GROUP BY`предложением в`SELECT`операторе. В этих случаях`GROUP BY`предложение
  делит набор результатов на группы строк, и агрегатные функции выполняют расчет для каждой группы,
  например, максимум, минимум, среднее и т. д.
  Вы можете использовать агрегатные функции как выражения только в следующих предложениях:
  * SELECT
  * HAVING
  Агрегирующие функции можно применять в сочетании с ключевым словом`DISTINCT`.
  В таком случае расчёты будут производиться только по уникальным значениям. 
  Если в случае с`MIN()`и`MAX()`это не имеет особого смысла, то при расчёте`AVG()`и`SUM()`иногда это бывает полезно.
 | SELECT SUM(DISTINCT column) 
 | FROM table
  Часто`DISTINCT`используется в сочетании с`COUNT()`— для подсчёта числа уникальных пользователей, уникальных заказов и т.д.
  Важно иметь в виду, что запрос со звёздочкой возвращает количество вообще всех записей, а запрос с указанием столбца —
  количество тех записей, где в заданном столбце значения не являются NULL.

ARRAY_LENGTH() .
  Вычисляет количество элементов в массиве (длину массива). 
  | array_length(anyarray, int)
  второй аргумент — это размерность массива, по которой считается его длина.
  | SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 1)
  | Результат:
  | 3
  | SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 2)
  | Результат:
  | 2
  Другие функции работы с массивами [https://www.postgresql.org/docs/8.4/functions-array.html]

unnest .
  Функция`unnest`предназначена для разворачивания массивов и превращения их в набор строк: 
  | SELECT unnest(ARRAY['one','two','three'])
  | Результат:
  | one
  | two
  | three
  В примере выше функция unnest превратила исходный список из трёх элементов в набор из трёх строк.
  Если бы в исходной таблице помимо списка был столбец с каким-либо значением, 
  то это значение автоматически проставилось бы напротив значений в каждой образовавшейся строке:
  | SELECT 'row', unnest(ARRAY['one','two','three'])
  | Результат:
  | row    one
  | row    two
  | row    three

AGE() .
  Возвращает разницу между двумя значениями в формате|TIMESTAMP|. При этом из первого значения вычитается второе,
  а сама разница получается в формате|INTERVAL|: 
  | SELECT AGE('2022-12-12', '2021-11-10')
  | Результат:
  | 397 days, 0:00:00
  Если в качестве первого аргумента не указать ничего, то на место первой даты автоматически подставится текущая дата
  (полночь текущего дня, т.е. его начало).
  Если сегодня 2022-12-12, то с 2021-11-10 прошло ровно столько дней: .
  | SELECT AGE(timestamp '2021-11-10')
  | Результат:
  | 397 days, 0:00:00
  На самом деле текущей дате соответствует значение|current_date|: .
  | SELECT AGE(current_date, '2021-11-10')
  | Результат:
  | 397 days, 0:00:00
  Cамо значение current_date можно вызвать так: .
  | SELECT current_date
  | Результат:
  | 12/12/22	
  И ещё один нюанс: чтобы результат отображался не в виде количества дней, 
  а в более удобном формате, можно переводить результат вычислений в тип|VARCHAR|:
  | SELECT AGE(current_date, '2021-11-10')::VARCHAR
  | Результат:
  | 1 year 1 mon 2 days

FILTER .
  Если после агрегирующей функции указать ключевое слово`FILTER`и поместить в скобках некоторое условие
  `condition`после`WHERE`, то агрегирующей функции на вход будут поданы только те строки, для которых 
  условие фильтра окажется истинным. 
  В общем виде эта конструкция выглядит так: .
  | SELECT agg_function(column) FILTER (WHERE [condition])
  | FROM table
  | Пример:
  | SELECT AVG(column_1) FILTER (WHERE column_2 > 100)
  | FROM table
  Это очень похоже на обычную фильтрацию с агрегацией, только в данном случае условие на отбор записей
  указывается сразу в блоке SELECT. Преимущество такой записи в том, что она позволяет проводить некоторые
  расчёты без необходимости писать отдельные запросы с блоком`WHERE`для получения промежуточных результатов.

GROUP BY .
  1. Сначала в таблице определяются строки, в которых в указанном в`GROUP BY`столбце есть одинаковые значения.
  2. Далее по этим значениям записи объединяются в группы, причём в группе может быть даже одна запись.
  3. После этого над элементами этих групп, как правило, проводятся какие-то операции с помощью агрегирующих 
  функций: 
  например, с помощью`SUM()`вычисляется сумма значений в каком-либо столбце в каждой группе: .
  | SELECT column_1, SUM(column_2)
  | FROM table
  | GROUP BY column_1
  4. Затем в результирующий запрос попадает по одной уникальной записи из столбца, по которому осуществлялась группировка.
  При этом напротив каждого такого значения отражается результат агрегации по соответствующей группе, если агрегация проводилась.
  Здесь важно сделать несколько уточнений .
  # Во-первых, группировка всегда выполняется после фильтрации, т.е. сначала выполняются инструкции в`WHERE`и
  только потом данные группируются через`GROUP BY`
  # Во-вторых, к образовавшимся в результате применения`GROUP BY`группам можно применять сразу несколько агрегирующих
  функций (в том числе к разным колонкам).
  # В-третьих, группировку можно делать сразу по новым полям, посчитанным в`SELECT`: При этом допускается использование
  в`GROUP BY`алиаса колонки, указанного в`SELECT`. 
  Следующие два запроса дадут одинаковый результат: .
  | SELECT DATE(column_1) AS date, SUM(column_2)
  | FROM table
  | GROUP BY DATE(column_1)
  
  | SELECT DATE(column_1) AS date, SUM(column_2)
  | FROM table
  | GROUP BY date
  # В-четвёртых, делать агрегацию после группировки необязательно. Если не указывать агрегирующую функцию,
  то запрос вернёт уникальные значения в столбце, т.е. тот же результат, что и оператор`DISTINCT` 
  Следующие два запроса дадут одинаковый результат: .
  | SELECT user_id
  | FROM user_actions
  | GROUP BY user_id
  
  | SELECT DISTINCT user_id
  | FROM user_actions
  И наконец, последнее важное уточнение: при использовании группировки колонки, указанные в`SELECT`,
  должны находиться и в`GROUP BY`, если они не используются в агрегационных функциях. 
  Это обязательное условие, и если оно не будет выполнено, то база данных вернёт ошибку.
  Следующий запрос работать не будет, так как в GROUP BY указаны не все неагрегированные колонки из блока`SELECT`: .
  | SELECT column_1, column_2, SUM(column_3)
  | FROM table
  | GROUP BY column_1
  В то же время такой запрос сработает: .
 | SELECT SUM(column_2)
  | FROM table
  | GROUP BY column_1
  Обратите внимание, что в этом запросе в блоке`SELECT`нет колонки, указанной в`GROUP BY`, 
  т.е. в обратную сторону правило не работает: если мы что-то указали в`GROUP BY`, 
  то это не обязательно указывать в`SELECT`. Иными словами, выводить наименования групп не обязательно.

  Вместо названий колонок в блоке`GROUP BY`можно использовать номер колонки, указанной в`SELECT` 
  Например, следующие два запроса эквивалентны: .
  | SELECT column_1, column_2, SUM(column_3)
  | FROM table
  | GROUP BY column_1, column_2
  
  | SELECT column_1, column_2, SUM(column_3)
  | FROM table
  | GROUP BY 1, 2
  При этом номера колонок из`SELECT`можно также использовать при сортировке в операторе`ORDER BY`.
  Можете сами поэкспериментировать с этим в следующих заданиях.

HAVING .
  В этом блоке нельзя указывать алиасы расчётных полей из блока SELECT`.
  Дело в том, что в соответствии с порядком выполнения запроса оператор`SELECT`выполняется
  после оператора`HAVING`. Поэтому агрегацию необходимо также указывать и в`HAVING`
  Например, такой запрос не сработает: .
  | SELECT column_1, SUM(column_2) AS new_column
  | FROM table
  | GROUP BY column_1
  | HAVING new_column = 10
  А такой сработает: .
  | SELECT column_1, SUM(column_2) AS new_column
  | FROM table
  | GROUP BY column_1
  | HAVING SUM(column_2) = 10


Задание:


Другие функции работы со строками: .
ASCII .
Возвращает ASCII код символа или Unicode код для UTF8 символа	
| ASCII(‘A’)	-- 65
CHR .
  конвертирует ASCII в символ или Unicode код в случае UTF8 
  | CHR(65)	-- ‘A’
CONCAT .
	Concatenate two or more strings into one	CONCAT(‘A’,’B’,’C’)	‘ABC’
CONCAT_WS .
	Concatenate strings with a separator	CONCAT_WS(‘,’,’A’,’B’,’C’)	‘A,B,C’
FORMAT .
	Format arguments based on a format string	FORMAT(‘Hello %s’,’PostgreSQL’)	‘Hello PostgreSQL’
INITCAP .
	преобразует строковое выражение в правильный регистр или регистр заглавий, 
  в котором первая буква каждого слова является прописной, а остальные символы — строчными.	
  | INITCAP(‘hI tHERE’)
  | Hi There
LEFT .
	Return the first n character in a string	LEFT(‘ABC’,1)	‘A’
LENGTH .
	Return the number of characters in a string	LENGTH(‘ABC’)	3
LOWER .
	Convert a string to lowercase	LOWER(‘hI tHERE’)	‘hi there’
LPAD .
	Pad on the left a a string with a character to a certain length	LPAD(‘123′, 5, ’00’)	‘00123’
LTRIM .
	Remove the longest string that contains specified characters from the left of the input string	LTRIM(‘00123’)	‘123’
MD5 .
	Return MD5 hash of a string in hexadecimal	MD5(‘ABC’)	
POSITION .
	Return the location of a substring in a string	POSTION(‘B’ in ‘A B C’)	3
REGEXP_MATCHES .
	Match a POSIX regular expression against a string and returns the matching substrings	SELECT REGEXP_MATCHES(‘ABC’, ‘^(A)(..)$’, ‘g’);	{A,BC}
REGEXP_REPLACE .
	Replace substrings that match a POSIX regular expression by a new substring	REGEXP_REPLACE(‘John Doe’,'(.*) (.*)’,’\2, \1′);	‘Doe, John’
REPEAT .
	Repeat string the specified number of times	REPEAT(‘*’, 5)	‘*****’
REPLACE .
	Replace all occurrences in a string of substring from with substring to	REPLACE(‘ABC’,’B’,’A’)	‘AAC’
REVERSE .
	Return reversed string.	REVERSE(‘ABC’)	‘CBA’
RIGHT .
	Return last n characters in the string. When n is negative, return all but first |n| characters.	RIGHT(‘ABC’, 2)	‘BC’
RPAD .
	Pad on the right of a string with a character to a certain length	RPAD(‘ABC’, 6, ‘xo’)	‘ABCxox’
RTRIM .
	Remove the longest string that contains specified characters from the right of the input string	RTRIM(‘abcxxzx’, ‘xyz’)	‘abc’
SPLIT_PART .
	разбивает строку по указанному разделителю и возвращает n-ю подстроку.	
  | SPLIT_PART(string, delimiter, position)
  | SPLIT_PART('2017-12-31','-'',2)	
  | '12'
SUBSTRING .
	Извлекает подстроку из строки
  | SUBSTRING ( string ,start_position , length )
  | SUBSTRING('ABC',1,1)
  | 'A'
TRIM .
	Убрирает указанные символы из начала и/или конца строки:	
  | TRIM([LEADING | TRAILING | BOTH] [characters] FROM string)
  | TRIM(' ABC  ')
  | 'ABC'
UPPER .
	конвертирует строку в верхний регистр
  | UPPER('hI tHERE')
  | 'HI THERE'

JOIN .
  `SQL`запросы позволяют выбирать и обрабатывать данные не только из одной таблицы с помощью подзапросов. 
  Но таблицы можно также объединять в один результирующий набор записей, связывая их по определённым условиям. 
  Это позволяет делать операция соединения`JOIN`

  Существуют следующие типы соединений таблиц: .
    * INNER JOIN
    * LEFT/RIGHT JOIN
    * FULL JOIN
    * CROSS JOIN 
  Операторы соединения включаются в раздел`FROM`запроса. В общем виде, вне зависимости от того, 
  какой тип соединения используется, запрос на объединение таблиц выглядит следующим образом:
  | SELECT ...
  | FROM table_1 
  |      JOIN table_2
  |      ON [condition]
  | ...
  Как правило (но далеко не всегда), в качестве условия|condition|, по которому происходит объединение, 
  выступает равенство значений в определённых столбцах. 
  В качестве таких столбцов обычно используются ключи с указанием id (товара, пользователя и т.д.), 
  то есть значений, по которым можно однозначно идентифицировать определённую сущность:
    | SELECT table_1.column_1, table_2.column_2
    | FROM table_1 
    |      JOIN table_2
    |      ON table_1.id = table_2.id
    | ...

  При этом у каждой колонки рекомендуется через точку указывать имя таблицы, которая содержит эту колонку. 
  Более того, это становится уже не рекомендацией, а необходимостью, когда имена столбцов в таблицах совпадают — 
  без явного указания источников база данных не сможет сама определить, какие столбцы и в каких таблицах вы имеете 
  в виду, и в результате вернёт ошибку.
  Если имена таблиц слишком длинные, таблицам можно присвоить алиасы. По этим же алиасам можно сразу удобно обращаться 
  к колонкам:
    | SELECT a.column_1, b.column_2
    | FROM table_1 a 
    |      JOIN table_2 b
    |      ON a.id = b.id
    | ...

  Если имя поля, по которому происходит объединение, совпадает в обеих таблицах (как в примерах выше), 
  то можно использовать сокращенную запись c оператором`USING`:
    | SELECT a.column_1, b.column_2
    | FROM table_1 a 
    |      JOIN table_2 b
    |      USING (id)
    | ...

  При объединении таблиц можно также использовать подзапросы. Их можно объединять с другими таблицами или друг с другом:
    | SELECT ...
    | FROM table_1
    |      JOIN (
    |           SELECT ...
    |           FROM table_2
    |      ) AS subquery
    |     ON table_1.id = subquery.id
    | ...

    | SELECT ...
    | FROM (
    |      SELECT ...
    |      FROM table_1
    | ) AS subquery_1
    |      JOIN (
    |           SELECT ...
    |           FROM table_2
    |      ) AS subquery_2
    |     ON subquery_1.id = subquery_2.id
    | ...

  Процесс объединения можно представить в виде следующей последовательности операций:
    1.  Сначала каждая строка первой таблицы сопоставляется с каждой строкой второй таблицы. 
        т.е. происходит декартово произведение двух множеств, результатом которого является новое множество, 
        состоящее из всевозможных пар исходных строк. 
        Например, если в одной таблице было 50 записей, а в другой 10, то в результате|декартова произведения| 
        получится 500 записей.
    2.  Затем для каждой объединённой строки, состоящей из строк двух исходных таблиц, проверяется условие соединения,
        указанное после оператора ON.
    3.  После этого в соответствии с выбранным типом объединения формируется результирующая таблица. 

  При соединении не двух, а нескольких таблиц, операция соединения выполняется последовательно несколько раз, 
  т.е. описанный выше алгоритм запускается столько раз, сколько указано соединений. 
  При этом в этой последовательности при каждом объединении может использоваться любой тип соединения (INNER, LEFT и т.д.).

  Для двух соединений запрос может выглядеть примерно следующим образом:
    | SELECT a.column_1, b.column_2
    | FROM table_1 a 
    |      LEFT JOIN table_2 b
    |      ON a.user_id = b.user_id
    |      JOIN table_3 c
    |      ON b.order_id = c.order_id
    | ...
   
  INNER JOIN .
  [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-inner-join/]
    Это оператор внутреннего соединения, для которого совершенно неважен порядок указания таблиц, 
    т.е. в следующих случаях результат объединения будет одинаковым:
    | SELECT ...
    | FROM table_1 INNER JOIN table_2
    |      ON [condition]
    | ...
    
    | SELECT ...
    | FROM table_2 INNER JOIN table_1 
    |      ON [condition]
    | ...
    При этом в запросе вместо INNER JOIN можно писать просто JOIN — это одно и то же.
    Результат объединения INNER JOIN формируется следующим образом: .
     * Сначала каждая строка первой таблицы сопоставляется с каждой строкой второй таблицы (происходит декартово произведение).
     * Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора ON.
     * После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
    Таким образом, в результате объединения INNER JOIN из двух таблиц отбрасываются все строки, 
    которые не прошли проверку на соответствие указанному условию. Вот и всё!

  LEFT JOIN .
  [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-left-join/]
  это оператор внешнего соединения, для которого важен порядок таблиц в запросе, т.е. в отличие от INNER JOIN
  он не является симметричным.
    Поэтому следующие две записи уже не являются эквивалентными: .
    | SELECT ...
    | FROM table_1 LEFT JOIN table_2
    |      ON [condition]
    | ...
    
    | SELECT ...
    | FROM table_2 LEFT JOIN table_1 
    |      ON [condition]
    | ...
    Результат объединения LEFT JOIN формируется следующим образом: .
      * Сначала каждая строка левой таблицы сопоставляется с каждой строкой правой таблицы (происходит декартово произведение).
      * Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора ON.
      * После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
      * Далее в результат добавляются те записи из левой таблицы 
      (внимание: только из левой), для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. 
      При этом для таких записей соответствующие поля из правой таблицы заполняются значениями NULL.
    Если внимательно посмотреть на описанный алгоритм, то можно понять, что он легко сводится к следующей последовательности 
    действий:
    * Сначала в соответствии с указанным условием выполняется INNER JOIN первой и второй таблиц.
    * Затем в результат добавляются те записи из левой таблицы (внимание: только из левой), 
    для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. 
    При этом для таких записей соответствующие поля из правой таблицы заполняются значениями NULL.
    `Соединение RIGHT JOIN работает аналогичным образом, только на втором этапе в результат INNER JOIN добавляются` 
    `записи не из левой, а из правой таблицы.`

  RIGHT JOIN .
  [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-right-join/]

  SELF JOIN .
  [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-self-join/]
    Самосоединение — это обычное соединение, которое соединяет таблицу с самой собой. 
    На практике самосоединение обычно используется для запроса иерархических данных или для сравнения строк в одной таблице.
    Чтобы сформировать самосоединение, вы указываете одну и ту же таблицу дважды с разными псевдонимами таблиц 
    и предоставляете предикат соединения после ONключевого слова.

  FULL OUTER JOIN .
  [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-full-outer-join/]
   или просто`FULL JOIN` 
    Это оператор полного внешнего соединения, для которого, как и для INNER JOIN, неважен порядок указания таблиц. 
    Однако работает он совсем по-другому.
    Запрос с FULL OUTER JOIN выглядит примерно так: .
      | SELECT ...
      | FROM table_1 FULL JOIN table_2
      |      ON [condition]
      | ...
      
      | SELECT ...
      | FROM table_2 FULL JOIN table_1 
      |      ON [condition]
      | ...
    
    Результат объединения FULL JOIN формируется следующим образом: .
      * Сначала каждая строка левой таблицы сопоставляется с каждой строкой правой таблицы (происходит декартово произведение).
      * Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора ON.
      * После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
      * Далее в результат добавляются те записи из левой и правой таблиц (внимание: из обеих таблиц), 
        для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. 
        При этом для таких записей соответствующие поля из другой таблицы 
        (для левой — это поля из правой, для правой — это поля из левой) заполняются значениями NULL.
    Этот алгоритм можно свести к следующей последовательности действий: .
      1 Сначала в соответствии с указанным условием выполняется INNER JOIN левой и правой таблиц.
      2 Далее в результат добавляются те записи из левой и правой таблиц (внимание: из обеих таблиц), 
        для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. 
        При этом для таких записей соответствующие поля из другой таблицы 
        (для левой — это поля из правой, для правой — это поля из левой) заполняются значениями NULL.


  CROSS JOIN .
  [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-cross-join/]
  позволяет вам производить декартово произведение строк в двух или более таблицах.
  В отличие от других предложений соединения , таких как LEFT JOIN  или INNER JOIN , это 
  CROSS JOIN предложение не имеет предиката соединения.
  Ниже показан синтаксис CROSS JOINсинтаксиса:
    | SELECT select_list
    | FROM T1
    | CROSS JOIN T2;
  Следующее утверждение эквивалентно приведенному выше утверждению:
   | SELECT select_list
   | FROM T1, T2;
  Кроме того, вы можете использовать INNER JOIN предложение с условием, которое всегда оценивается как истинное,
  для имитации перекрестного соединения:
    | SELECT *
    | FROM T1
    | INNER JOIN T2 ON true;

  NATURAL JOIN .
  [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-natural-join/]
  это соединение, которое создает неявное соединение на основе тех же имен столбцов в соединяемых таблицах.
  Ниже показан синтаксис естественного соединения PostgreSQL:
    | SELECT select_list
    | FROM T1
    | NATURAL [INNER, LEFT, RIGHT] JOIN T2;
Естественным соединением может быть внутреннее соединение , левое соединение или правое соединение.
Если вы не укажете объединение явно, например, INNER JOIN, LEFT JOIN, RIGHT JOIN, PostgreSQL будет использовать 
INNER JOIN по умолчанию.

Операции с множествами: UNION, EXCEPT, INTERSECT .
  Они позволяют комбинировать результаты нескольких запросов друг с другом и получать один общий результат. 
  Причём именно комбинировать, а не объединять, как это делают джойны.
  Эту разницу важно понимать: в операциях с множествами не происходит совмещения столбцов из двух таблиц — 
  база данных просто отбирает строки из таблиц, удовлетворяющие типу операции, и добавляет их в общий результат.

  Операции с множествами имеют следующий синтаксис: .
    | SELECT column_1, column_2
    | FROM table_1
    | UNION
    | SELECT column_1, column_2
    | FROM table_2
    
    | SELECT column_1, column_2
    | FROM table_1
    | EXCEPT
    | SELECT column_1, column_2
    | FROM table_2
      
    | SELECT column_1, column_2
    | FROM table_1
    | INTERSECT
    | SELECT column_1, column_2
    | FROM table_2

  Операция`UNION`объединяет записи из двух запросов в один общий результат (|объединение множеств|).
  Операция`EXCEPT`возвращает все записи, которые есть в первом запросе, но отсутствуют во втором (|разница множеств|).
  Операция`INTERSECT`возвращает все записи, которые есть и в первом, и во втором запросе (|пересечение множеств|).
  При этом по умолчанию эти операции исключают из результата строки-дубликаты. 
  Чтобы дубликаты не исключались из результата, необходимо после имени операции указать ключевое слово`ALL` 
  Например, так:
    | SELECT column_1, column_2
    | FROM table_1
    | UNION ALL
    | SELECT column_1, column_2
    | FROM table_2
    
  Для работы этих операций необходимо, чтобы выполнялись следующие условия:
  * В каждом запросе в SELECT должно быть одинаковое количество столбцов.
  * Типы данных в столбцах должны быть совместимы.
  При этом количество столбцов в операторе SELECT может быть любым — главное, чтобы оно было одинаковым.
  Например, следующий запрос вернёт уникальные id пользователей, которые что-то заказывали в нашем сервисе,
  но которых по какой-то причине нет в таблице users:
    | SELECT user_id
    | FROM user_actions
    | EXCEPT
    | SELECT user_id
    | FROM users
  Про UNION: [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-union/] 
  Про EXCEPT: [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-except/]
  Про INTERSECT: [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-intersect/]
  О теории множеств: [https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2#%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F]

Оконные функции .
  Оконными называют функции, которые обрабатывают выделенные наборы строк (окна или партиции) 
  и записывают результаты вычислений в отдельном столбце.
  Одно из главных преимуществ оконных функций заключается в том, что они возвращают ровно то же количество записей,
  которое получили на вход.
  Представьте, что вы хотите рассчитать некоторое значение для группы строк, объединённых общим признаком 
  (например, id пользователя). Если бы вы воспользовались оператором GROUP BY, то на выходе вместо исходного 
  количества строк в группе получили бы одну строку с результатом.
  При группировке так происходит всегда — число строк в результирующей таблице всегда равно количеству групп 
  в исходной таблице. В то же время оконная функция позволяет проводить те же расчёты с агрегацией по группам, 
  но при этом сохраняет структуру исходной таблицы — для каждой записи, принадлежащей определённой группе, 
  в отдельном столбце просто указывается результат агрегации.
  Определяются окна с помощью оператора`OVER`— 
  в общем виде его синтаксис выглядит так: .
  | OVER (
  |      PARTITION BY column_1, column_2, ...    - определяются партиции внутри окна (аналог GROUP BY) 
  |      ORDER BY column_3, ...    - указывается сортировка записей в партициях
  |      ROWS/RANGE BETWEEN ...    - задаются границы окна
  | )
  Для проведения вычислений по заданному в`OVER`окну используются разные функции. 
  Например, с агрегирующей функцией`SUM`запись может выглядеть следующим образом:
  | SELECT SUM(column) OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS sum
  | FROM table
  Теперь несколько слов об инструкциях, которые можно указывать при создании окна. Всего их три:
  * |PARTITION BY| 
  * |ORDER BY ASC/DESC|
  * |ROWS/RANGE BETWEEN|
  При этом все они являются необязательными.
  Инструкция|PARTITION BY|определяет столбец, по которому данные будут делиться на группы, 
  которые называются партициями. Например, так будет выглядеть группировка по user_id:
    | SELECT user_id, date, price, 
    |        SUM(price) OVER (PARTITION BY user_id) AS sum
    | FROM table
  В результате такого запроса для каждой записи в таблице будет вычислена общая сумма всех покупок данного пользователя, 
  а результат вычислений будет вписан в столбец sum.
  Инструкция|ORDER BY|определяет столбец, по которому значения внутри окна будут сортироваться при обработке.
  Например, сортировка по date внутри окна задаётся так:
    | SELECT user_id, date, price, 
    |        SUM(price) OVER (PARTITION BY user_id ORDER BY date) AS sum
    | FROM table
  В этом случае для каждой записи в таблице будет вычислена сумма текущей и всех предыдущих покупок пользователя. 
  Результат вычислений будет вписан в столбец sum.
  Почему же считается сумма именно текущей и всех предыдущих, а не вообще всех покупок пользователя?
  Дело в том, что при использовании оконных функций в паре с агрегирующими для каждой строки определяется 
  так называемая рамка окна — набор строк в её партиции. Если в|OVER|указать |ORDER BY|, то по умолчанию рамка 
  будет состоять из всех строк от начала партиции до текущей строки (также в рамку будут включены строки, равные 
  текущей строке по значению, указанному в ORDER BY).
  Именно поэтому в нашем примере сумма считается по каждому пользователю нарастающим итогом.
  Если же|ORDER BY|не указывать, то рамка по умолчанию будет состоять из всех строк партиции, 
  т.е. будет посчитана сумма всех покупок каждого пользователя. 
  Также можно не указывать и|PARTITION BY|— тогда рамкой окна станет вся таблица, и мы просто посчитаем 
  сумму покупок всех пользователей:
    | SELECT user_id, date, price, 
    |        SUM(price) OVER () AS sum
    | FROM table
  Инструкции|ROWS| и |RANGE|могут дополнительно задавать границы рамки окна и ограничивать 
  диапазон работы функций внутри партиции. Первым аргументом указывается начало рамки, вторым — конец рамки:
    | SELECT user_id, date, price, 
    |        SUM(price) OVER (PARTITION BY user_id ORDER BY date ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS sum
    | FROM table
  В результате для каждой записи в таблице будет вычислена сумма текущей и предыдущей покупок пользователя, 
  а результат будет снова вписан в столбец sum.
  Рамку можно задать в двух режимах:
  * |ROWS|— начало и конец рамки определяются строками относительно текущей строки. 
  * |RANGE|— начало и конец рамки задаются разницей значений в столбце из|ORDER BY|
  Начало и конец рамки задаются одним из следующих способов:
  * |UNBOUNDED PRECEDING|
  *  значение|PRECEDING|
  * |CURRENT ROW|
  *  значение|FOLLOWING|
  * |UNBOUNDED FOLLOWING|

  # |UNBOUNDED PRECEDING|— указывает, что рамка начинается с первой строки партиции.
  # |UNBOUNDED FOLLOWING|— указывает, что рамка заканчивается на последней строке партиции.
  #  значение|PRECEDING| и значение|FOLLOWING|— указывают, что рамка начинается или заканчивается 
  #  со сдвигом на заданное число строк относительно текущей строки.
  # |CURRENT ROW| — указывает, что рамка начинается или заканчивается на текущей строке.
  Рамка всегда начинается с начала рамки и заканчивается концом рамки. 
  Если конец рамки опущен, подразумевается|CURRENT ROW| 
  По умолчанию рамка определяется так:
  | RANGE UNBOUNDED PRECEDING
  Это равносильно расширенному определению рамки:
  | RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  Варианты значение|PRECEDING| и значение|FOLLOWING| допускаются только в режиме ROWS.
  Например, следующая запись означает создание рамки, включающей 3 строки до текущей и 3 строки после текущей 
  (разумеется, текущая строка тоже включается в рамку):
  | ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING
  Если в инструкции|ORDER BY|находится столбец date с типом данных DATE, то рамку окна можно задать следующим образом:
  | RANGE BETWEEN '3 days' PRECEDING AND '3 days' FOLLOWING
  Это будет означать рамку, включающую 3 дня перед и 3 дня после текущей даты (включая текущую дату).
  При указании рамки через|RANGE|обязательным условием является указание только одного столбца в инструкции ORDER BY.
  Как и все остальные инструкции, инструкция|ROWS/RANGE BETWEEN|является необязательной.
  Также важно знать, что оконные функции разрешается использовать в запросе только в |SELECT| и |ORDER BY|. 
  Во всех остальных операторах, включая WHERE, HAVING и GROUP BY, они запрещены, так как логически выполняются 
  после обычных агрегирующих функций.
  Если необходимо отфильтровать или сгруппировать строки после вычисления оконных функций, 
  можно использовать вложенный запрос:
    | SELECT user_id, date, price, sum
    | FROM (
    |     SELECT user_id, date, price, SUM(price) OVER (PARTITION BY user_id ORDER BY date) AS sum
    |     FROM table
    | ) t
    | WHERE sum > 1000
  Над результатом оконных функций можно производить разные арифметические операции. 
  Также результат оконных функций может выступать в качестве аргумента других функций:
  |   SELECT user_id, date, price, 1.15 * SUM(price) OVER (PARTITION BY user_id ORDER BY date) AS sum
  |   FROM table

    | SELECT user_id, date, price, ROUND(AVG(price) OVER (PARTITION BY user_id ORDER BY date), 2) AS sum
    | FROM table
  Также при определении инструкций внутри окна можно использовать расчётные поля:
    | SELECT user_id, date, price, SUM(price) OVER (PARTITION BY DATE_TRUNC('month', date)) AS monthly_sum
    | FROM table
  Сами окна можно также определять через оператор|WINDOW|, а затем вызывать по алиасу в операторе SELECT:
  |   SELECT SUM(column) OVER w AS sum
  |   FROM table
  |   WHERE ...
  |   GROUP BY ...
  |   HAVING ...
  |   WINDOW w AS (
  |       PARTITION BY ... 
  |       ORDER BY ...
  |       ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  |       )
  |   ORDER BY ...
  |   LIMIT ... 
  В паре с оконными функциями могут использоваться функции разных классов:
  1. Агрегирующие функции SUM, AVG, MAX, MIN, COUNT
    Внутри окна к таким функциям может применяться|ORDER BY| Так, сортировка позволит получить вместо общей суммы 
    нарастающую, а вместо абсолютного максимума — максимум среди значений вплоть до текущего.
  2. Ранжирующие функции:
    |ROW_NUMBER|— простая нумерация (1, 2, 3, 4, 5).
    |RANK|— нумерация с учётом повторяющихся значений с пропуском рангов (1, 2, 2, 4, 5).
    |DENSE_RANK|— нумерация с учётом повторяющихся значений без пропуска рангов (1, 2, 2, 3, 4).
    Разумеется, для функций ранжирования всегда нужно указывать|ORDER BY|, иначе они будут работать некорректно.
  3. Функции смещения:
  |LAG, LEAD|— значение предыдущей или следующей строки.
  |FIRST_VALUE, LAST_VALUE|— первое или последнее значение в окне.
  Для функций смещения определение правил сортировки тоже необходимо.
  
  Ранжирующие функции: .
    |   SELECT ROW_NUMBER() OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS row_number
    | FROM table
    
    | SELECT RANK() OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS rank
    | FROM table
     
    | SELECT DENSE_RANK() OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS dense_rank
    | FROM table
  
  Функции смещения .
    | SELECT LAG(column, 1) OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS lag_value
    | FROM table
    |
    | SELECT LEAD(column, 1) OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS lead_value
    | FROM table
    В качестве первого аргумента у функций|LAG| и |LEAD|указывается колонка со значениями, в качестве второго — то, 
    на какое число строк производить смещение (назад и вперёд соответственно). 
    Второй аргумент можно не указывать, по умолчанию его значение равно 1.
    LAG() .
    [https://www.postgresqltutorial.com/postgresql-window-function/postgresql-lag-function/]
    LEAD() .
    [https://www.postgresqltutorial.com/postgresql-window-function/postgresql-lead-function/]

ROWS_BETWEEN .
  |Скользящее среднее| —  это показатель, который вычисляется в каждой точке временного ряда как среднее значение 
                          за N предыдущих периодов (дней, недель, месяцев и т.д. в зависимости от уровня агрегации данных). 
                          Скользящее среднее как бы перемещается по временному ряду и каждый раз учитывает фиксированное 
                          количество значений — для проведения таких расчётов как раз и нужна рамка окна, 
                          которая задаётся инструкцией`ROWS BETWEEN`

  Начало и конец рамки задаются следующими способами: .
  | UNBOUNDED PRECEDING 
  | [значение] PRECEDING
  | CURRENT ROW
  | [значение] FOLLOWING
  | UNBOUNDED FOLLOWING
  Вот ещё один пример указания границ рамки: .
    | SELECT SUM(column_3) OVER (PARTITION BY column_1 
    |                          ORDER BY column_2 
    |                          ROWS BETWEEN UNBOUNDED PRECEDING AND 3 FOLLOWING) AS sum
    | FROM table
CASE и оконные функции .
  пример: .
    | SELECT
    |     CASE
    |     WHEN SUM(column) OVER (...) > 100 THEN 'above 100'
    |     WHEN SUM(column) OVER (...) < 100 THEN 'below 100'
    |     ELSE 'equal 100'
    |     END AS sum_case
    | FROM table

  Если к определению оконной функции добавить предложение`FILTER`, то в окно попадут только те входные строки, 
  для которых условие фильтра будет вычислено как истинное.
  При этом предложение`FILTER`допускается только для агрегирующих оконных функций.
  В общем виде вся конструкция выглядит так: .
    | SELECT agg_function(column) FILTER (WHERE [condition]) OVER (...)
    | FROM table
  Пример: .
    | SELECT SUM(column_1) FILTER (WHERE column_2 > 100) OVER (PARTITION BY column_3 ORDER BY column_4) AS sum
    | FROM table


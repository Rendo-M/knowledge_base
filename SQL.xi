Structure Querry Language .
  Основные принципы реляционных баз данных: .
    * все данные на концептуальном уровне представляются в виде объектов, 
      заданных в виде строк и столбцов, называемых отношением, более распространенное
      название – таблица;
    * в пересечение строки и столбца таблицы можно занести только одно значение;
    * все операции выполняются над целыми отношениями и результатом этих операций
      является отношение.

  отношение .
    это структура данных целиком, набор записей (в обычном понимании – таблица)
  кортеж .
    это каждая строка , содержащая данные (более распространенный термин – запись )
    все кортежи в отношении должны быть различны;
  мощность .
    число кортежей в таблице (проще говоря, число записей)
    мощность отношения может быть любой (от 0 до бесконечности),
    порядок следования кортежей - неважен;
  атрибут .
    это столбец в таблице (более распространенный термин – поле )     
  размерность .
    это число атрибутов в таблице
    размерность отношения должна быть больше 0, порядок следования атрибутов существенен;
  домен атрибута .
    это допустимые значения (неповторяющиеся), которые можно занести в поле
      

    Порядок операторов в запросе: .
        SELECT 'столбцы или * для выбора всех столбцов; обязательно' .
        FROM 'таблица; обязательно' .
        WHERE 'условие/фильтрация, например, city = 'Moscow'; необязательно' .
        GROUP BY 'столбец, по которому хотим сгруппировать данные; необязательно' .
        HAVING 'условие/фильтрация на уровне сгруппированных данных; необязательно' .
        ORDER BY 'столбец, по которому хотим отсортировать вывод; необязательно' .
        LIMIT X -- ограничение количества выводимых записей .

    Тем не менее важно понимать, что порядок выполнения операторов в
    СУБД несколько отличается от порядка их написания в запросе.
    В упрощённом виде порядок выполнения запроса в PostgreSQL такой: .
      FROM -- указание источника данных .
      WHERE -- фильтрация данных .
      GROUP BY -- группировка данных .
      HAVING -- фильтрация данных после группировки .
      SELECT -- перечисление полей результирующей таблицы .
      ORDER BY -- сортировка результирующей таблицы .
      LIMIT -- ограничение количества выводимых записей .

    Таким образом:
    * Сначала с помощью FROM определяется таблица.
    * Затем в соответствии с указанным в WHERE условием из этой таблицы отбираются записи.
    * Потом выбранные данные группируются и агрегируются с помощью GROUP BY.
    * Далее из агрегированных записей отбираются те, которые удовлетворяют условию в HAVING.
    * Только после этого в соответствии с указанными в SELECT инструкциями формируется результирующая таблица — 
      производятся все необходимые вычисления, присваиваются новые имена и т.д.
    * Затем результирующая таблица сортируется в соответствии с ORDER BY.
    * И наконец срабатывает ограничение на количество строк, указанное в LIMIT.

    И ещё один важный совет. Обратите внимание, что фильтрацию данных по неагрегированным значениям
    можно делать как в блоке WHERE, так и в блоке HAVING. Внимательно посмотрите на следующие запросы:

   | SELECT sex, COUNT(user_id)
   | FROM users
   | WHERE sex != 'male'
   | GROUP BY sex

   | SELECT sex, COUNT(user_id)
   | FROM users
   | GROUP BY sex
   | HAVING sex != 'male'
    Их результат будет одинаковым.
    Однако делать фильтрацию по неагрегированным данным рекомендуется именно в блоке WHERE, 
    т.е. заранее. В таком случае вы ещё до группировки убираете из расчётов ненужные вам данные
    и таким образом не расходуете вычислительные ресурсы на подсчёт значений, которые всё равно
    будут отфильтрованы вами позже.
    Это важный момент, касающийся оптимизации SQL-запросов.

  Подзапросы .
    — это всего лишь запрос внутри другого запроса.
    Подзапросы могут применяться в следующих частях основного запроса: .
    * в операторе FROM;
    * в операторе SELECT (если запрос возвращает один столбец с одним значением);
    * в операторах WHERE и HAVING (если запрос возвращает один столбец с одним или несколькими значениями).
    
    Прежде всего важно понять, что к результату выполнения подзапроса можно обращаться так же, 
    как и к таблицам в базе данных, т.е. использовать их в блоке FROM вместо имеющихся таблиц:
    | SELECT column_1
    | FROM (
    |     SELECT column_1, column_2
    |     FROM table
    | ) AS subquery_1
    В рамках данного запроса сначала будет выполнен подзапрос, который отберёт колонки 
    column_1 и column_2 из таблицы table, а затем уже из образовавшейся таблицы основной запрос выберет колонку column_1.

    Подзапрос, возвращающий одно значение, может использоваться как обычное значение совместно с операторами сравнения.
    
    Важный момент: при использовании подзапроса в блоке FROM сформированной на основе подзапроса таблице
    необходимо присвоить какой-нибудь алиас, иначе основной запрос не сработает.
    В примере выше мы обозначили результат подзапроса как subquery_1.
    Кроме того, уровней вложенности может быть несколько: .
    | SELECT column_1
    | FROM (
    |     SELECT column_1, column_2
    |     FROM (
    |         SELECT column_1, column_2, column_3
    |         FROM table
    |     ) AS subquery_1
    | ) AS subquery_2
    В данном случае последовательность работы запроса такая: 
    сначала будет выполнен подзапрос, возвращающий результат subquery_1, 
    затем подзапрос, возвращающий результат subquery_2, 
    и только потом в результате основного подзапроса попадёт колонка column_1. 
    В результате получается что-то похожее на матрёшку, при этом к основной таблице table обращается
    только самый первый подзапрос subquery_1.
    Приведённый пример довольно условный и на практике колонки таким образом отбирать не стоит,
    но общую идею он должен передавать.
    Понимание того, как работают подзапросы в блоке FROM, пригодится, при оъединении разных таблиц.
    Подзапрос, возвращающий несколько значений, может использоваться в блоке`WHERE`совместно с оператором`IN` — 
    например, когда нам нужно проверить, совпадает ли значение в столбце с одним из значений из определённого множества, 
    полученного в результате выполнения подзапроса.
    При использовании в операторе`WHERE`табличного выражения обратиться просто к его имени нельзя —
    необходимо предварительно выбрать все его записи. т.е. написать подзапрос. 
    При этом в табличном выражении должен быть всего один столбец, иначе база данных вернёт ошибку.

  Типичные ошибки при написании SQL-запросов: .
  * Неправильный порядок или ошибки в ключевых словах. 
  * Неправильно названы используемые в запросе функции и операторы (например, DATEPART, а не DATE_PART).
  * Неправильно указаны имена столбцов.
  * Неправильно выполнена сортировка записей.
  * Неправильно проведены расчёты.
  * Пропущена запятая при перечислении столбцов в SELECT
  * Лишняя запятая после имени последнего столбца в SELECT
  * Не закрыты скобки (проверьте, что количество открывающих скобок равно количеству закрывающих).
  * Допущена ошибка в подзапросе (перед выполнением всего запроса проверьте, что работают отдельные подзапросы).
  * Запущены сразу несколько запросов, не разделённые точкой с запятой.

ORDER BY .
  Сортировать результат SQL-запроса можно сразу по нескольким колонкам,
  указывая их после ORDER BY через запятую вместе с направлением сортировки (`ASC` или `DESC`).
  При этом по умолчанию сортировка происходит по возрастанию, т.е.`ASC`указывать не обязательно.
  
  | SELECT column
  | FROM table
  | ORDER BY column -- сортировка по возрастанию
    
  | SELECT column
  | FROM table
  | ORDER BY column ASC -- сортировка по возрастанию
  |  
  | SELECT column
  | FROM table
  | ORDER BY column DESC -- сортировка по убыванию
  |
  | SELECT column_1, column_2
  | FROM table
  | ORDER BY column_1 DESC, column_2 -- сначала сортировка по первой колонке (по убыванию), 
  |                                  -- затем по второй (по возрастанию)

LIMIT .
  ограничивает число извлекаемых из таблицы записей.
  Записывается он так:
  | SELECT column
  | FROM table
  | LIMIT n 
  На месте n может быть любое целое число — ровно столько записей, сколько вам необходимо.
  Если n превысит количество записей в таблице, то в результат попадут все записи.   

WITH .
  позволяет создавать так называемые табличные выражения 
  (CTE, common table expressions) — временные таблицы, существующие только для одного запроса.
  Их основное предназначение заключается в разбиении сложных запросов на несколько частей.
  Табличные выражения создаются так: .
  | WITH subquery_1 AS (
  |     SELECT column_1, column_2
  |     FROM table
  |     )
  | SELECT column_1
  | FROM subquery_1 
  Сравните запрос выше с результатом запроса из прошлого шага:
  | SELECT column_1
  | FROM (
  |     SELECT column_1, column_2
  |     FROM table
  | ) AS subquery_1
  Оператор WITH может содержать несколько табличных выражений, причём к указанным ранее выражениям 
  можно обращаться в последующих выражениях:
  | WITH subquery_1 AS (
  |     SELECT column_1, column_2, column_3
  |     FROM table
  |     ),
  |      subquery_2 AS (
  |     SELECT column_1, column_2
  |     FROM subquery_1
  |     )
  | SELECT column_1
  | FROM subquery_2
  Можете снова сравнить запрос выше с запросом из прошлого шага:
  | SELECT column_1
  | FROM (
  |     SELECT column_1, column_2
  |     FROM (
  |         SELECT column_1, column_2, column_3
  |         FROM table
  |     ) AS subquery_1
  | ) AS subquery_2
  

  Использовать в своих запросах оператор WITH или нет — решать вам,
  но в некоторых случаях он может упростить работу с кодом запроса.
  Подробнее про WITH и табличные выражения можно почитать [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-cte/]

AS .
  При составлении SQL-запросов колонкам в результирующей таблице можно присваивать любые другие имена
  (их называют «алиасы»). Это можно делать с помощью оператора `AS`:

  | SELECT name AS new_name
  | FROM table
  Если вдруг вам покажется, что на написание оператора AS уходит слишком много времени,
  то его можно опустить, указав новое имя колонки без него.
  Так тоже сработает:
  | SELECT name new_name
  | FROM table

CAST .
  Иногда возникает необходимость изменить тип данных в какой-нибудь колонке результирующей таблицы, 
  не меняя при этом свойства исходной таблицы.
  Например, можно преобразовать число в текст (тип данных VARCHAR) — для этого существует оператор`CAST`:
  | SELECT CAST(numbers AS VARCHAR)
  | FROM table
  Также это можно сделать с помощью специального синтаксиса:
  | SELECT numbers::VARCHAR
  | FROM table

DATE_PART .
  В отдельных таблицах некоторые колонки представлены в формате даты (DATE) и времени (TIMESTAMP).
  На практике бывают такие задачи, когда нужна, например, не вся дата, а какая-то её часть: год, месяц, день, час и т.д.
  Извлечь эту часть из исходных данных позволяет функция DATE_PART.
  Синтаксис следующий:
  | SELECT DATE_PART(part, column)
  На месте|part|нужно в кавычках указать ту часть, которую необходимо извлечь: 
  |'century', 'decade', 'year', 'month', 'day', 'hour', 'minute', 'second', 'microseconds', 'milliseconds',|
  |'dow', 'doy', 'epoch', 'isodow', 'isoyear', 'timezone', 'timezone_hour', 'timezone_minute'|
  На месте|column|следует указать нужную колонку либо конкретную дату/время.
  Пример:
  | SELECT DATE_PART('day', TIMESTAMP '2022-01-12')
  Результат:
  | 12

DATE_TRUNC .
  используется для усечения дат и времени, т.е. она работает почти как округление`ROUND`, 
  только для типов данных`TIMESTAMP`и`INTERVAL`
 Синтаксис, как и у `DATE_PART`:
  | SELECT DATE_TRUNC(part, column) 
  На месте`part`в кавычках указывается, до какой точности следует обрезать переданное значение времени:
  'year', 'month', 'day', 'hour' и т.д.
  Возвращаемое значение имеет тип`TIMESTAMP`или`INTERVAL`, а все «части» исходного значения, менее значимые, 
  чем заданная «часть», приравниваются к нулю (или единице, если это номер дня или месяца):
  | SELECT DATE_TRUNC('month', TIMESTAMP '2022-01-12 08:55:30')
  | Результат:
  | 01/01/22 00:00
  | SELECT DATE_TRUNC('day', TIMESTAMP '2022-01-12 08:55:30')
  | Результат:
  | 12/01/22 00:00	
  | SELECT DATE_TRUNC('hour', TIMESTAMP '2022-01-12 08:55:30')
  | Результат:
  | 12/01/22 08:00	

INTERVAL .
  Чтобы отложить от даты или прибавить к ней какой-то промежуток времени, 
  можно использовать несложные арифметические операции с датами. 
  Например, от текущей даты можно отнять какой-то промежуток`INTERVAL`:
  | SELECT NOW() - INTERVAL '1 year 2 months 1 week'
  | Результат:
  | 10/10/21 19:32
  NOW() — функция, которая позволяет получать текущую дату и время (в вашем случае она будет другой): .
  | SELECT NOW()
  | Результат:
  | 17/12/22 19:32

COALESCE .
  возвращает первое не NULL значение из списка поданных ей на вход аргументов:
  |   SELECT COALESCE(NULL, 'I am not NULL' , 25)
  | Результат:
  | 'I am not NULL'

  | SELECT COALESCE(NULL, 25, 'I am not NULL' )
  | Результат:
  | 25

  Чтобы заполнить пропуски в колонке, достаточно применить функцию COALESCE к колонке с пропусками
  и указать в качестве второго аргумента то значение, которое мы хотим видеть вместо NULL:
  | SELECT COALESCE(column, 'filler value')
  | FROM table
  Функция`COALESCE`принимает неограниченное количество аргументов. Он возвращает первый аргумент, который не равен NULL.
  Если все аргументы равны NULL,`COALESCE`функция вернет значение null.

  Функция`COALESCE`оценивает аргументы слева направо, пока не найдет первый ненулевой аргумент. 
  Все остальные аргументы из первого ненулевого аргумента не оцениваются.
  Функция COALESCE обеспечивает ту же функциональность, что`NVL`и `IFNULL` функция, предоставляемая стандартом SQL.
  MySQL имеет функцию`IFNULL`, а Oracle предоставляет`NVL`функцию.

  Мы часто используем эту`COLAESCE`функцию для замены нулевых значений значением по умолчанию при запросе данных.
  Например, мы хотим отобразить отрывок из сообщения в блоге, если отрывок не указан, мы можем использовать первые 
  150 символов содержимого сообщения. 
  Для этого мы можем использовать`COALESCE`функцию следующим образом:

  | SELECT
  | 	COALESCE (excerpt, LEFT(CONTENT, 150))
  | FROM
  | 	posts;

CONCAT .
  Функция`CONCAT`принимает на вход несколько аргументов и возвращает результат их последовательного сложения друг с другом.
  При этом аргументы не обязательно должны быть выражены строками — главное, они должны быть конвертируемыми в строки.
  | SELECT CONCAT('SQL', ' ', 'Simulator ', 2022)
  | Результат:
  | SQL Simulator 2022

CONCAT_WS .
  объединяет строки в одну, разделенную определенным разделителем. Кстати, WS означает с разделителем
  | CONCAT_WS(separator,str_1,str_2,...);

Арифметические операторы .
  Для работы с числовыми значениями в PostgreSQL доступны разные арифметические операторы:
  `+ - * / % ^` etc. [https://www.postgresql.org/docs/9.3/functions-math.html]
  Если бы мы захотели перевести 6200 рублей в доллары по курсу 1 доллар = 62 рубля,
  то операция выглядела бы следующим образом:
  | SELECT 6200 / 62
  | Результат:
  | 100

CASE .
  Выражение CASE проходит через условия и возвращает значение при выполнении первого условия 
  (как оператор if-then-else). Итак, как только условие истинно, оно прекращает чтение и возвращает результат.
  Если никакие условия не выполняются, возвращается значение в ELSE предложении.
  Если ELSE часть отсутствует и ни одно условие не выполняется, возвращается NULL.
| CASE
|     WHEN condition1 THEN result1
|     WHEN condition2 THEN result2
|     WHEN conditionN THEN resultN
|     ELSE result
| END;
  Пример: .
  Следующая конструкция разобъёт весь список наименований на три категории: «мясо», «рыба» и «другое». 
  Соответственно, если в первых двух условиях мы не учтём какие-то наименования из колонки name 
  (например, «телятину»), то они попадут в категорию «другое».
  | SELECT CASE 
  |        WHEN name='свинина' OR name='баранина' OR name='курица' THEN 'мясо'
  |        WHEN name='треска' OR name='форель' OR name='окунь' THEN 'рыба'
  |        ELSE 'другое'
  |        END AS сategory
  | FROM table
  Пример2: .
 Повысьте цену на 5% только на те товары, цена которых превышает 100 рублей. Цену остальных товаров оставьте без изменений.
 Также не повышайте цену на икру, которая и так стоит 800 рублей. Выведите id и наименования всех товаров, их старую и новую цену.
 Цену округлять не нужно. Колонку с новой ценой снова назовите new_price. 
 Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.
  |   SELECT product_id, name, price,
  |     CASE 
  |     WHEN name = 'икра' THEN price
  |     WHEN price > 100 THEN price * 1.05 
  |     ELSE price
  |     END AS new_price
  | FROM products
  | ORDER BY new_price DESC, product_id
  приоритеты выполнения операций: .
    * умножение и деление (* и /)
    * сложение и вычитание (+ и -)
    * операторы сравнения (=, !=, >, <, >=, <=)
    * NOT
    * AND
    * OR

LIKE .
| value LIKE pattern
  Проверяет строки на соответствие заданному шаблону: если строка ему соответствует, то возвращается TRUE,
  в противном случае — FALSE. 

  Шаблоны могут содержать как обычные символы, так и символы-шаблоны: знак процента ( % ) и подчёркивание ( _ ).
  Подчёркивание подменяет любой одиночный символ, а знак процента — любую (в том числе и пустую) последовательность символов:

  Обратите внимание на последний пример: оператор LIKE чувствителен к регистру.
  Если шаблон не содержит знаков процента и подчёркиваний, тогда шаблон представляет
  собой строку и LIKE работает как оператор сравнения, проверяя строки на точное совпадение.

IN/BETWEEN .
  | WHERE product_name IN (product_1, product_2, product_3, ...)
  | WHERE value BETWEEN 5 AND 10
  | WHERE date BETWEEN '2022-11-10' AND '2022-12-10'
  | WHERE product_name NOT IN (product_1, product_2, product_3, ...)
  | WHERE value NOT BETWEEN 5 AND 10

DISTINCT .
  позволяет отбирать уникальные значения в колонке, т.е.избавляться от всех дубликатов. 
  Указывается`DISTINCT`сразу после`SELECT`:
  | SELECT DISTINCT column
  | FROM table
  Если вы укажете несколько столбцов,`DISTINCT`предложение будет оценивать дубликат на основе комбинации значений этих столбцов.
  | SELECT
  |    DISTINCT column1, column2
  | FROM
  |    table_name;
  В этом случае комбинация значений в обоих столбцах column1 и column2 будет использоваться для оценки дубликата.
  PostgreSQL также позволяет DISTINCT ON (expression) сохранить «первую» строку каждой группы дубликатов,
  используя следующий синтаксис:
  |   SELECT
  |    DISTINCT ON (column1) column_alias,
  |    column2
  | FROM
  |    table_name
  | ORDER BY
  |    column1,
  |    column2;
  Порядок строк, возвращаемых`SELECT`оператором, не указан, поэтому «первая» строка каждой группы дубликата также не указана.
  Хорошей практикой является всегда использовать`ORDER BY`предложение с,`DISTINCT ON(expression)`чтобы сделать результирующий
  набор предсказуемым.
  Обратите внимание, что`DISTINCT ON`выражение должно соответствовать самому левому выражению в`ORDER BY`предложении.

АГРЕГИРУЮЩИЕ ФУНКЦИИ .
  Агрегирующие функции выполняют вычисления для набора строк и возвращают одну строку.
  * COUNT() — считает количество значений в колонке.
  * SUM() — вычисляет сумму значений.
  * AVG() — вычисляет среднее значение.
  * MAX() — вычисляет максимальное значение.
  * MIN() — вычисляет минимальное значение.
  Некоторые из вышеуказанных функций нельзя применять к колонкам с текстом, датами и временем, так как не вполне понятно,
  что, например, означает найти среднее значение или сумму наименований товаров. 
  В то же время «максимальное» наименование товара вычислить можно — функция MAX() будет искать наибольшее значение 
  в упорядоченной последовательности символов (в данном случае — упорядоченной по алфавиту).

  Мы часто используем агрегатные функции с`GROUP BY`предложением в`SELECT`операторе. В этих случаях`GROUP BY`предложение
  делит набор результатов на группы строк, и агрегатные функции выполняют расчет для каждой группы,
  например, максимум, минимум, среднее и т. д.
  Вы можете использовать агрегатные функции как выражения только в следующих предложениях:
  * SELECT
  * HAVING
  Агрегирующие функции можно применять в сочетании с ключевым словом`DISTINCT`.
  В таком случае расчёты будут производиться только по уникальным значениям. 
  Если в случае с`MIN()`и`MAX()`это не имеет особого смысла, то при расчёте`AVG()`и`SUM()`иногда это бывает полезно.
 | SELECT SUM(DISTINCT column) 
 | FROM table
  Часто`DISTINCT`используется в сочетании с`COUNT()`— для подсчёта числа уникальных пользователей, уникальных заказов и т.д.
  Важно иметь в виду, что запрос со звёздочкой возвращает количество вообще всех записей, а запрос с указанием столбца —
  количество тех записей, где в заданном столбце значения не являются NULL.

ARRAY_LENGTH() .
  Вычисляет количество элементов в массиве (длину массива). 
  | array_length(anyarray, int)
  второй аргумент — это размерность массива, по которой считается его длина.
  | SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 1)
  | Результат:
  | 3
  | SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 2)
  | Результат:
  | 2
  Другие функции работы с массивами [https://www.postgresql.org/docs/8.4/functions-array.html]

unnest .
  Функция`unnest`предназначена для разворачивания массивов и превращения их в набор строк: 
  | SELECT unnest(ARRAY['one','two','three'])
  | Результат:
  | one
  | two
  | three
  В примере выше функция unnest превратила исходный список из трёх элементов в набор из трёх строк.
  Если бы в исходной таблице помимо списка был столбец с каким-либо значением, 
  то это значение автоматически проставилось бы напротив значений в каждой образовавшейся строке:
  | SELECT 'row', unnest(ARRAY['one','two','three'])
  | Результат:
  | row    one
  | row    two
  | row    three

AGE() .
  Возвращает разницу между двумя значениями в формате|TIMESTAMP|. При этом из первого значения вычитается второе,
  а сама разница получается в формате|INTERVAL|: 
  | SELECT AGE('2022-12-12', '2021-11-10')
  | Результат:
  | 397 days, 0:00:00
  Если в качестве первого аргумента не указать ничего, то на место первой даты автоматически подставится текущая дата
  (полночь текущего дня, т.е. его начало).
  Если сегодня 2022-12-12, то с 2021-11-10 прошло ровно столько дней: .
  | SELECT AGE(timestamp '2021-11-10')
  | Результат:
  | 397 days, 0:00:00
  На самом деле текущей дате соответствует значение|current_date|: .
  | SELECT AGE(current_date, '2021-11-10')
  | Результат:
  | 397 days, 0:00:00
  Cамо значение current_date можно вызвать так: .
  | SELECT current_date
  | Результат:
  | 12/12/22	
  И ещё один нюанс: чтобы результат отображался не в виде количества дней, 
  а в более удобном формате, можно переводить результат вычислений в тип|VARCHAR|:
  | SELECT AGE(current_date, '2021-11-10')::VARCHAR
  | Результат:
  | 1 year 1 mon 2 days

FILTER .
  Если после агрегирующей функции указать ключевое слово`FILTER`и поместить в скобках некоторое условие
  `condition`после`WHERE`, то агрегирующей функции на вход будут поданы только те строки, для которых 
  условие фильтра окажется истинным. 
  В общем виде эта конструкция выглядит так: .
  | SELECT agg_function(column) FILTER (WHERE [condition])
  | FROM table
  | Пример:
  | SELECT AVG(column_1) FILTER (WHERE column_2 > 100)
  | FROM table
  Это очень похоже на обычную фильтрацию с агрегацией, только в данном случае условие на отбор записей
  указывается сразу в блоке SELECT. Преимущество такой записи в том, что она позволяет проводить некоторые
  расчёты без необходимости писать отдельные запросы с блоком`WHERE`для получения промежуточных результатов.

GROUP BY .
  1. Сначала в таблице определяются строки, в которых в указанном в`GROUP BY`столбце есть одинаковые значения.
  2. Далее по этим значениям записи объединяются в группы, причём в группе может быть даже одна запись.
  3. После этого над элементами этих групп, как правило, проводятся какие-то операции с помощью агрегирующих 
  функций: 
  например, с помощью`SUM()`вычисляется сумма значений в каком-либо столбце в каждой группе: .
  | SELECT column_1, SUM(column_2)
  | FROM table
  | GROUP BY column_1
  4. Затем в результирующий запрос попадает по одной уникальной записи из столбца, по которому осуществлялась группировка.
  При этом напротив каждого такого значения отражается результат агрегации по соответствующей группе, если агрегация проводилась.
  Здесь важно сделать несколько уточнений .
  # Во-первых, группировка всегда выполняется после фильтрации, т.е. сначала выполняются инструкции в`WHERE`и
  только потом данные группируются через`GROUP BY`
  # Во-вторых, к образовавшимся в результате применения`GROUP BY`группам можно применять сразу несколько агрегирующих
  функций (в том числе к разным колонкам).
  # В-третьих, группировку можно делать сразу по новым полям, посчитанным в`SELECT`: При этом допускается использование
  в`GROUP BY`алиаса колонки, указанного в`SELECT`. 
  Следующие два запроса дадут одинаковый результат: .
  | SELECT DATE(column_1) AS date, SUM(column_2)
  | FROM table
  | GROUP BY DATE(column_1)
  
  | SELECT DATE(column_1) AS date, SUM(column_2)
  | FROM table
  | GROUP BY date
  # В-четвёртых, делать агрегацию после группировки необязательно. Если не указывать агрегирующую функцию,
  то запрос вернёт уникальные значения в столбце, т.е. тот же результат, что и оператор`DISTINCT` 
  Следующие два запроса дадут одинаковый результат: .
  | SELECT user_id
  | FROM user_actions
  | GROUP BY user_id
  
  | SELECT DISTINCT user_id
  | FROM user_actions
  И наконец, последнее важное уточнение: при использовании группировки колонки, указанные в`SELECT`,
  должны находиться и в`GROUP BY`, если они не используются в агрегационных функциях. 
  Это обязательное условие, и если оно не будет выполнено, то база данных вернёт ошибку.
  Следующий запрос работать не будет, так как в GROUP BY указаны не все неагрегированные колонки из блока`SELECT`: .
  | SELECT column_1, column_2, SUM(column_3)
  | FROM table
  | GROUP BY column_1
  В то же время такой запрос сработает: .
 | SELECT SUM(column_2)
  | FROM table
  | GROUP BY column_1
  Обратите внимание, что в этом запросе в блоке`SELECT`нет колонки, указанной в`GROUP BY`, 
  т.е. в обратную сторону правило не работает: если мы что-то указали в`GROUP BY`, 
  то это не обязательно указывать в`SELECT`. Иными словами, выводить наименования групп не обязательно.

  Вместо названий колонок в блоке`GROUP BY`можно использовать номер колонки, указанной в`SELECT` 
  Например, следующие два запроса эквивалентны: .
  | SELECT column_1, column_2, SUM(column_3)
  | FROM table
  | GROUP BY column_1, column_2
  
  | SELECT column_1, column_2, SUM(column_3)
  | FROM table
  | GROUP BY 1, 2
  При этом номера колонок из`SELECT`можно также использовать при сортировке в операторе`ORDER BY`.
  Можете сами поэкспериментировать с этим в следующих заданиях.

HAVING .
  В этом блоке нельзя указывать алиасы расчётных полей из блока SELECT`.
  Дело в том, что в соответствии с порядком выполнения запроса оператор`SELECT`выполняется
  после оператора`HAVING`. Поэтому агрегацию необходимо также указывать и в`HAVING`
  Например, такой запрос не сработает: .
  | SELECT column_1, SUM(column_2) AS new_column
  | FROM table
  | GROUP BY column_1
  | HAVING new_column = 10
  А такой сработает: .
  | SELECT column_1, SUM(column_2) AS new_column
  | FROM table
  | GROUP BY column_1
  | HAVING SUM(column_2) = 10


Задание:


Другие функции работы со строками: .
ASCII .
Возвращает ASCII код символа или Unicode код для UTF8 символа	
| ASCII(‘A’)	-- 65
CHR .
  конвертирует ASCII в символ или Unicode код в случае UTF8 
  | CHR(65)	-- ‘A’
CONCAT .
	Concatenate two or more strings into one	CONCAT(‘A’,’B’,’C’)	‘ABC’
CONCAT_WS .
	Concatenate strings with a separator	CONCAT_WS(‘,’,’A’,’B’,’C’)	‘A,B,C’
FORMAT .
	Format arguments based on a format string	FORMAT(‘Hello %s’,’PostgreSQL’)	‘Hello PostgreSQL’
INITCAP .
	преобразует строковое выражение в правильный регистр или регистр заглавий, 
  в котором первая буква каждого слова является прописной, а остальные символы — строчными.	
  | INITCAP(‘hI tHERE’)
  | Hi There
LEFT .
	Return the first n character in a string	LEFT(‘ABC’,1)	‘A’
LENGTH .
	Return the number of characters in a string	LENGTH(‘ABC’)	3
LOWER .
	Convert a string to lowercase	LOWER(‘hI tHERE’)	‘hi there’
LPAD .
	Pad on the left a a string with a character to a certain length	LPAD(‘123′, 5, ’00’)	‘00123’
LTRIM .
	Remove the longest string that contains specified characters from the left of the input string	LTRIM(‘00123’)	‘123’
MD5 .
	Return MD5 hash of a string in hexadecimal	MD5(‘ABC’)	
POSITION .
	Return the location of a substring in a string	POSTION(‘B’ in ‘A B C’)	3
REGEXP_MATCHES .
	Match a POSIX regular expression against a string and returns the matching substrings	SELECT REGEXP_MATCHES(‘ABC’, ‘^(A)(..)$’, ‘g’);	{A,BC}
REGEXP_REPLACE .
	Replace substrings that match a POSIX regular expression by a new substring	REGEXP_REPLACE(‘John Doe’,'(.*) (.*)’,’\2, \1′);	‘Doe, John’
REPEAT .
	Repeat string the specified number of times	REPEAT(‘*’, 5)	‘*****’
REPLACE .
	Replace all occurrences in a string of substring from with substring to	REPLACE(‘ABC’,’B’,’A’)	‘AAC’
REVERSE .
	Return reversed string.	REVERSE(‘ABC’)	‘CBA’
RIGHT .
	Return last n characters in the string. When n is negative, return all but first |n| characters.	RIGHT(‘ABC’, 2)	‘BC’
RPAD .
	Pad on the right of a string with a character to a certain length	RPAD(‘ABC’, 6, ‘xo’)	‘ABCxox’
RTRIM .
	Remove the longest string that contains specified characters from the right of the input string	RTRIM(‘abcxxzx’, ‘xyz’)	‘abc’
SPLIT_PART .
	разбивает строку по указанному разделителю и возвращает n-ю подстроку.	
  | SPLIT_PART(string, delimiter, position)
  | SPLIT_PART('2017-12-31','-'',2)	
  | '12'
SUBSTRING .
	Извлекает подстроку из строки
  | SUBSTRING ( string ,start_position , length )
  | SUBSTRING('ABC',1,1)
  | 'A'
TRIM .
	Убрирает указанные символы из начала и/или конца строки:	
  | TRIM([LEADING | TRAILING | BOTH] [characters] FROM string)
  | TRIM(' ABC  ')
  | 'ABC'
UPPER .
	конвертирует строку в верхний регистр
  | UPPER('hI tHERE')
  | 'HI THERE'

JOIN .
  `SQL`запросы позволяют выбирать и обрабатывать данные не только из одной таблицы с помощью подзапросов. 
  Но таблицы можно также объединять в один результирующий набор записей, связывая их по определённым условиям. 
  Это позволяет делать операция соединения`JOIN`

  Существуют следующие типы соединений таблиц: .
    * INNER JOIN
    * LEFT/RIGHT JOIN
    * FULL JOIN
    * CROSS JOIN 
  Операторы соединения включаются в раздел`FROM`запроса. В общем виде, вне зависимости от того, 
  какой тип соединения используется, запрос на объединение таблиц выглядит следующим образом:
  | SELECT ...
  | FROM table_1 
  |      JOIN table_2
  |      ON [condition]
  | ...
  Как правило (но далеко не всегда), в качестве условия|condition|, по которому происходит объединение, 
  выступает равенство значений в определённых столбцах. 
  В качестве таких столбцов обычно используются ключи с указанием id (товара, пользователя и т.д.), 
  то есть значений, по которым можно однозначно идентифицировать определённую сущность:
    | SELECT table_1.column_1, table_2.column_2
    | FROM table_1 
    |      JOIN table_2
    |      ON table_1.id = table_2.id
    | ...

  При этом у каждой колонки рекомендуется через точку указывать имя таблицы, которая содержит эту колонку. 
  Более того, это становится уже не рекомендацией, а необходимостью, когда имена столбцов в таблицах совпадают — 
  без явного указания источников база данных не сможет сама определить, какие столбцы и в каких таблицах вы имеете 
  в виду, и в результате вернёт ошибку.
  Если имена таблиц слишком длинные, таблицам можно присвоить алиасы. По этим же алиасам можно сразу удобно обращаться 
  к колонкам:
    | SELECT a.column_1, b.column_2
    | FROM table_1 a 
    |      JOIN table_2 b
    |      ON a.id = b.id
    | ...

  Если имя поля, по которому происходит объединение, совпадает в обеих таблицах (как в примерах выше), 
  то можно использовать сокращенную запись c оператором`USING`:
    | SELECT a.column_1, b.column_2
    | FROM table_1 a 
    |      JOIN table_2 b
    |      USING (id)
    | ...

  При объединении таблиц можно также использовать подзапросы. Их можно объединять с другими таблицами или друг с другом:
    | SELECT ...
    | FROM table_1
    |      JOIN (
    |           SELECT ...
    |           FROM table_2
    |      ) AS subquery
    |     ON table_1.id = subquery.id
    | ...

    | SELECT ...
    | FROM (
    |      SELECT ...
    |      FROM table_1
    | ) AS subquery_1
    |      JOIN (
    |           SELECT ...
    |           FROM table_2
    |      ) AS subquery_2
    |     ON subquery_1.id = subquery_2.id
    | ...

  Процесс объединения можно представить в виде следующей последовательности операций:
    1.  Сначала каждая строка первой таблицы сопоставляется с каждой строкой второй таблицы. 
        т.е. происходит декартово произведение двух множеств, результатом которого является новое множество, 
        состоящее из всевозможных пар исходных строк. 
        Например, если в одной таблице было 50 записей, а в другой 10, то в результате|декартова произведения| 
        получится 500 записей.
    2.  Затем для каждой объединённой строки, состоящей из строк двух исходных таблиц, проверяется условие соединения,
        указанное после оператора ON.
    3.  После этого в соответствии с выбранным типом объединения формируется результирующая таблица. 

  При соединении не двух, а нескольких таблиц, операция соединения выполняется последовательно несколько раз, 
  т.е. описанный выше алгоритм запускается столько раз, сколько указано соединений. 
  При этом в этой последовательности при каждом объединении может использоваться любой тип соединения (INNER, LEFT и т.д.).

  Для двух соединений запрос может выглядеть примерно следующим образом:
    | SELECT a.column_1, b.column_2
    | FROM table_1 a 
    |      LEFT JOIN table_2 b
    |      ON a.user_id = b.user_id
    |      JOIN table_3 c
    |      ON b.order_id = c.order_id
    | ...
   
  INNER JOIN .
  [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-inner-join/]
    Это оператор внутреннего соединения, для которого совершенно неважен порядок указания таблиц, 
    т.е. в следующих случаях результат объединения будет одинаковым:
    | SELECT ...
    | FROM table_1 INNER JOIN table_2
    |      ON [condition]
    | ...
    
    | SELECT ...
    | FROM table_2 INNER JOIN table_1 
    |      ON [condition]
    | ...
    При этом в запросе вместо INNER JOIN можно писать просто JOIN — это одно и то же.
    Результат объединения INNER JOIN формируется следующим образом: .
     * Сначала каждая строка первой таблицы сопоставляется с каждой строкой второй таблицы (происходит декартово произведение).
     * Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора ON.
     * После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
    Таким образом, в результате объединения INNER JOIN из двух таблиц отбрасываются все строки, 
    которые не прошли проверку на соответствие указанному условию. Вот и всё!

  LEFT JOIN .
  [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-left-join/]
  это оператор внешнего соединения, для которого важен порядок таблиц в запросе, т.е. в отличие от INNER JOIN
  он не является симметричным.
    Поэтому следующие две записи уже не являются эквивалентными: .
    | SELECT ...
    | FROM table_1 LEFT JOIN table_2
    |      ON [condition]
    | ...
    
    | SELECT ...
    | FROM table_2 LEFT JOIN table_1 
    |      ON [condition]
    | ...
    Результат объединения LEFT JOIN формируется следующим образом: .
      * Сначала каждая строка левой таблицы сопоставляется с каждой строкой правой таблицы (происходит декартово произведение).
      * Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора ON.
      * После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
      * Далее в результат добавляются те записи из левой таблицы 
      (внимание: только из левой), для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. 
      При этом для таких записей соответствующие поля из правой таблицы заполняются значениями NULL.
    Если внимательно посмотреть на описанный алгоритм, то можно понять, что он легко сводится к следующей последовательности 
    действий:
    * Сначала в соответствии с указанным условием выполняется INNER JOIN первой и второй таблиц.
    * Затем в результат добавляются те записи из левой таблицы (внимание: только из левой), 
    для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. 
    При этом для таких записей соответствующие поля из правой таблицы заполняются значениями NULL.
    `Соединение RIGHT JOIN работает аналогичным образом, только на втором этапе в результат INNER JOIN добавляются` 
    `записи не из левой, а из правой таблицы.`

  RIGHT JOIN .
  [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-right-join/]

  SELF JOIN .
  [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-self-join/]
    Самосоединение — это обычное соединение, которое соединяет таблицу с самой собой. 
    На практике самосоединение обычно используется для запроса иерархических данных или для сравнения строк в одной таблице.
    Чтобы сформировать самосоединение, вы указываете одну и ту же таблицу дважды с разными псевдонимами таблиц 
    и предоставляете предикат соединения после ONключевого слова.

  FULL OUTER JOIN .
  [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-full-outer-join/]
   или просто`FULL JOIN` 
    Это оператор полного внешнего соединения, для которого, как и для INNER JOIN, неважен порядок указания таблиц. 
    Однако работает он совсем по-другому.
    Запрос с FULL OUTER JOIN выглядит примерно так: .
      | SELECT ...
      | FROM table_1 FULL JOIN table_2
      |      ON [condition]
      | ...
      
      | SELECT ...
      | FROM table_2 FULL JOIN table_1 
      |      ON [condition]
      | ...
    
    Результат объединения FULL JOIN формируется следующим образом: .
      * Сначала каждая строка левой таблицы сопоставляется с каждой строкой правой таблицы (происходит декартово произведение).
      * Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора ON.
      * После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
      * Далее в результат добавляются те записи из левой и правой таблиц (внимание: из обеих таблиц), 
        для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. 
        При этом для таких записей соответствующие поля из другой таблицы 
        (для левой — это поля из правой, для правой — это поля из левой) заполняются значениями NULL.
    Этот алгоритм можно свести к следующей последовательности действий: .
      1 Сначала в соответствии с указанным условием выполняется INNER JOIN левой и правой таблиц.
      2 Далее в результат добавляются те записи из левой и правой таблиц (внимание: из обеих таблиц), 
        для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. 
        При этом для таких записей соответствующие поля из другой таблицы 
        (для левой — это поля из правой, для правой — это поля из левой) заполняются значениями NULL.


  CROSS JOIN .
  [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-cross-join/]
  позволяет вам производить декартово произведение строк в двух или более таблицах.
  В отличие от других предложений соединения , таких как LEFT JOIN  или INNER JOIN , это 
  CROSS JOIN предложение не имеет предиката соединения.
  Ниже показан синтаксис CROSS JOINсинтаксиса:
    | SELECT select_list
    | FROM T1
    | CROSS JOIN T2;
  Следующее утверждение эквивалентно приведенному выше утверждению:
   | SELECT select_list
   | FROM T1, T2;
  Кроме того, вы можете использовать INNER JOIN предложение с условием, которое всегда оценивается как истинное,
  для имитации перекрестного соединения:
    | SELECT *
    | FROM T1
    | INNER JOIN T2 ON true;

  NATURAL JOIN .
  [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-natural-join/]
  это соединение, которое создает неявное соединение на основе тех же имен столбцов в соединяемых таблицах.
  Ниже показан синтаксис естественного соединения PostgreSQL:
    | SELECT select_list
    | FROM T1
    | NATURAL [INNER, LEFT, RIGHT] JOIN T2;
Естественным соединением может быть внутреннее соединение , левое соединение или правое соединение.
Если вы не укажете объединение явно, например, INNER JOIN, LEFT JOIN, RIGHT JOIN, PostgreSQL будет использовать 
INNER JOIN по умолчанию.

Операции с множествами: UNION, EXCEPT, INTERSECT .
  Они позволяют комбинировать результаты нескольких запросов друг с другом и получать один общий результат. 
  Причём именно комбинировать, а не объединять, как это делают джойны.
  Эту разницу важно понимать: в операциях с множествами не происходит совмещения столбцов из двух таблиц — 
  база данных просто отбирает строки из таблиц, удовлетворяющие типу операции, и добавляет их в общий результат.

  Операции с множествами имеют следующий синтаксис: .
    | SELECT column_1, column_2
    | FROM table_1
    | UNION
    | SELECT column_1, column_2
    | FROM table_2
    
    | SELECT column_1, column_2
    | FROM table_1
    | EXCEPT
    | SELECT column_1, column_2
    | FROM table_2
      
    | SELECT column_1, column_2
    | FROM table_1
    | INTERSECT
    | SELECT column_1, column_2
    | FROM table_2

  Операция`UNION`объединяет записи из двух запросов в один общий результат (|объединение множеств|).
  Операция`EXCEPT`возвращает все записи, которые есть в первом запросе, но отсутствуют во втором (|разница множеств|).
  Операция`INTERSECT`возвращает все записи, которые есть и в первом, и во втором запросе (|пересечение множеств|).
  При этом по умолчанию эти операции исключают из результата строки-дубликаты. 
  Чтобы дубликаты не исключались из результата, необходимо после имени операции указать ключевое слово`ALL` 
  Например, так:
    | SELECT column_1, column_2
    | FROM table_1
    | UNION ALL
    | SELECT column_1, column_2
    | FROM table_2
    
  Для работы этих операций необходимо, чтобы выполнялись следующие условия:
  * В каждом запросе в SELECT должно быть одинаковое количество столбцов.
  * Типы данных в столбцах должны быть совместимы.
  При этом количество столбцов в операторе SELECT может быть любым — главное, чтобы оно было одинаковым.
  Например, следующий запрос вернёт уникальные id пользователей, которые что-то заказывали в нашем сервисе,
  но которых по какой-то причине нет в таблице users:
    | SELECT user_id
    | FROM user_actions
    | EXCEPT
    | SELECT user_id
    | FROM users
  Про UNION: [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-union/] 
  Про EXCEPT: [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-except/]
  Про INTERSECT: [https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-intersect/]
  О теории множеств: [https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2#%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F]



